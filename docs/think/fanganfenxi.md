# 一次技术方案的分析过程

> 分析技术方案时，保持以终为始的原则。思维就像一棵树，方案就像树枝，遍历之后发现不可行，只需要往根部回溯，重新思考达到目标的其它方法。


## 背景
这是我负责的一个H5项目，内嵌于APP的webview，页面跳转通过打开新的webview来实现类app的效果。

在app内从另外一个项目跳转到该应用时，需要带上一个sourceid，标记引流入口。sourceid可能是来源于首页或者商品详情页，只有在下单的时候会提交给订单。

任务
对该sourceid生命周期的要求是： 外部项目跳转进入该项目之后，到关闭由它打开的所有页面为止，算一个生命周期。

## 行动
### 从页面跳转传参入手
app为和提供了桥接sdk，应用内webview调用的是同一个api，打开新窗口前可以使用proxy拦截该api，获取当前窗口的链接，将链接上的sourceid带到新窗口上，实现sourceid参数的透传。

这个方法简单粗暴，却有明显的缺点：
* 业务和工具耦合，不利于维护
* 分享转发前需要把该参数去掉，会影响到旧的逻辑
* 该方法可行，但是属于对公共代码的修改，容易引发bug，暂时纳入备选方案。

### 从本地存储方案入手
浏览器本地缓存方案有localstorage、sessionStorage、cookie。这些方案在webview中是否也适用呢？

经过在ios中验证localstorage的缓存行为和浏览器类似，sessionStorage和cookie在webview之间不共享，因此2者被排除。

> 请教了ios客户端的同事，了解到，ios平台的app目前使用的是WKwebview实现，窗口之间使用的是不同的WKProcessPool，所以数据共享是个问题，localstorage之所以看起来像是共享了，实际上只是在打开同源窗口时复制了一份，新开的窗口对localStorgae所做的修改不会对旧窗口有影响。这些问题在以前UIwebview开发的时代是不存在的，而UIwebview的是因为内存占用过高而逐渐被淘汰。

可共享的存储方案就只剩下localstorage。由于localstorage属于持久化存储，想要识别一次完整使用，需要抓住一个边界点：要如何识别一次完整使用，是否具有开始或者结束的标志。在这个边界点更新sourceid

完整使用的标志有：
* 该webview是应用中当前存在的唯一本项目的webview，标记一次使用的开始
* 应用中当前存在的唯一本项目的webview被销毁，标记一次使用的结束

这2种标志如何去标记呢？我想到了以下办法：
* app提供相关api告诉我们是否是同源webview的第一个页面，就像微信小程序那样，打开非首页的头部左上角会显示一个home按钮。很遗憾没有找到相关api。
* 像window.onbeforeunload那样监听页面销毁，存储过sourceid的页面在页面销毁前销毁缓存的sourceid。通俗来讲，就是自产自销（销毁）。经测试发现，webview关闭并不会触发window.onbeforeunload和onunload事件。该方法不可行。

### 不那么完美的实现方案
当没有完美的解决方案时，问自己，我们真的一定要完美的实现吗？经过和产品的讨论，产品方认为，不需要。可以根据用户的使用习惯，大致确定sourceid的合理有效时间，通过localstorage实现超时清理方案。

## 结论
又一个很简单的决策公式：决策 = 收益 - 成本 - 风险
以下列出了暂时可行的方案评估表：

方案 | 收益 | 成本（开发）| 风险（上线+后期维护）| 决策
---|---|---|---|---
proxy拦截api添加参数 | 10 | 3 | 1+1 | 5
localstorage有效期 | 8 | 1 | 0+0 | 7 

根据上表的结果，最终选择了“localstorage有效期”这个方案。



