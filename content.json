{"pages":[{"title":"分类","text":"","link":"/categories/index.html"}],"posts":[{"title":"qiankun","text":"看到了一篇很不错的文章，很详细的描述了qiankun的设计思想，有缺点。 如何设计实现微前端框架-qiankun","link":"/2021/06/22/architecture/qiankun/"},{"title":"百度地图自定义标记","text":"最近有个业务要用到百度地图以及自定义自定义图标功能。具体浏览地址：锦江酒店-分销通需要实现的效果如下： 需要满足的交互： 左侧列表滚动时，右侧地图中心位置的标记变为左侧鼠标所在的商品上 鼠标放置在地图标记上时，显示这个标记对应的酒店名称，点击这个标记跳转到酒店详情页 这个需求的核心任务是： 地图SDK选择 实现地图的自定义标记 自定义标记的状态变化 自定义标记的点击事件监听 地图SDK选择可以选择的地图有： 腾讯 高德 百度 谷歌 我们的酒店有海外数据，由于目前（2018-11）腾讯和高德地图均未很完美的支持海外位置服务。剩下只有百度和谷歌。谷歌地图经使用发现有一些外部资源依赖被防火墙阻挡。因此最终选择了百度地图。 异步加载地图123456789101112131415161718192021222324252627282930313233343536373839404142class BaiduMap { constructor(eleId, clickCallback, coordinate) { this.mapConfig = {} this.mapContainer = eleId this.map = null this.markers = null this.hotelList = '' this.hotel = '' this.clickCallback = clickCallback this.coordinate = coordinate if (!window.BMap) { BMapSource = this.loadMap() BMapSource.then(this.initMap) } } // 1.加载地图 loadMap() { const AK = 'ySDvqVVO3wnmQS49H355c5dhl6ewk469' const BMap_URL = 'https://api.map.baidu.com/api?v=2.0&amp;amp;ak=' + AK + '&amp;s=1&amp;callback=BMapCallback' return new Promise((resolve, reject) =&gt; { // 插入script脚本 let scriptNode = document.createElement('script') scriptNode.setAttribute('type', 'text/javascript') scriptNode.setAttribute('src', BMap_URL) document.body.appendChild(scriptNode) // 百度地图异步加载回调处理 window.BMapCallback = function () { resolve(window.BMap) } }) } // 2. 初始化地图 initMap(BMap) { // ... }} 实现地图的自定义标记使用Marker类实现自定义标记。 label.addEventListener监听mouseout,mouseover事件，改变mark样式，实现标记状态变化。 Icon类添加标记图标 Label类添加文本标记 addOverlay方法将marker添加到地图上 panTo方法将某个坐标移动到地图中心位置 label.addEventListener监听click事件，实现点击跳转交互 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 3. 批量添加标记setBatchMarker() { // 为每个酒店添加一个标记 this.markers = this.hotelList.map((hotel, index) =&gt; { let new_point = new BMap.Point(hotel.longitude, hotel.latitude) let marker = new BMap.Marker(new_point) // 设置标注图标 let icon = new BMap.Icon(defaultIcon, new BMap.Size(30, 30)) marker.setIcon(icon) // 创建marker默认的标记 let content = `&lt;div&gt;&lt;span class=&quot;markerIndex&quot;&gt;${index + 1}&lt;/span&gt;&lt;span class=&quot;markerLabel&quot;&gt;${hotel.translatedName || hotel.hotelName}&lt;/span&gt;&lt;/div&gt;` let label = new BMap.Label(content, { position: new_point }) label.setStyle({ padding: 0, width: '30px', height: '30px', lineHeight: '30px', backgroundColor: 'transparent', border: 'none', color: '#fff', textAlign: 'center', overflow: 'hidden' }) marker.setLabel(label) this.map.addOverlay(marker) // 将标注添加到地图中 // 设置marker的鼠标事件（鼠标进入和离开的样式差异） // 鼠标经过时 label.addEventListener('mouseover', function () { // 修改样式 }) // 鼠标离开时 label.addEventListener('mouseout', function (e) { // 修改样式 }) // 点击 label.addEventListener('click', function (e) { // 跳转 }) return marker }) // 以列表的第一个为地图的中心点 let new_point = new BMap.Point( this.hotelList[0].longitude, this.hotelList[0].latitude ) // 将地图的中心点更改为给定的点，跳转到指定中心点进行渲染。如果该点在当前的地图视图中已经可见，则会以平滑动画的方式移动到中心点位置。 this.map.panTo(new_point)}","link":"/2018/11/05/blogs/baidu-map-mark/"},{"title":"base64学习笔记","text":"学习背景webpack打包经常将图片内联进js代码中，内联格式就是base64。image标签本身支持base64格式。base64更像是二进制格式的马甲，由于所有字符都是可见字符，因此可以安全的运行在各个平台上而不会丢失数据。 参考资料： http://www.ruanyifeng.com/blog/2008/06/base64.html https://www.zhihu.com/question/36306744 编码原理base64，包含64个可见字符： 小写字母a-z 大写字母A-Z 数字0-9 符号”+”、”/“ 再加上作为垫字的”=”（实际上是65个字符） 编码步骤： 每三个字节作为一组，一共是24个二进制位。不足3个字节的分组在结尾补0。空出来的全0字节最终编码为= 将这24个二进制位分为四组，每个组有6个二进制位 在每组前面加两个00，扩展成32个二进制位，即四个字节 新的二进制串，每个字节对应base64基本字符中的某个字符 base64 字节值-&gt;字符映射表1234567891011121314151617181920212223242526272829303132330 A 17 R 34 i 51 z 1 B 18 S 35 j 52 0 2 C 19 T 36 k 53 1 3 D 20 U 37 l 54 2 4 E 21 V 38 m 55 3 5 F 22 W 39 n 56 4 6 G 23 X 40 o 57 5 7 H 24 Y 41 p 58 6 8 I 25 Z 42 q 59 7 9 J 26 a 43 r 60 8 10 K 27 b 44 s 61 9 11 L 28 c 45 t 62 + 12 M 29 d 46 u 63 / 13 N 30 e 47 v 14 O 31 f 48 w 15 P 32 g 49 x 16 Q 33 h 50 y 编码率24个字符扩展成32个字符，编码后的文本比原文本大三分之一。","link":"/2021/06/20/blogs/base64/"},{"title":"代码简洁之道","text":"代码简洁之道这篇文章是从掘金上看到的，整理的很不错，故收藏，有比较大的参考价值传送门","link":"/2019/02/04/blogs/code-clean/"},{"title":"关于浏览器的CSP（Content-Security-Policy）","text":"在浏览器命令行执行eval函数时，发现在有些网页的devTools中执行时报错： 12345VM132:1 Uncaught EvalError: Refused to evaluate a string as JavaScript because 'unsafe-eval' is not an allowed source of script in the following Content Security Policy directive: &quot;script-src github.githubassets.com&quot;. at new Function (&lt;anonymous&gt;) at &lt;anonymous&gt;:1:15(anonymous) @ VM132:1 而在其它大部分网页的devTools中执行是正常的。 根据报错信息大致明白：该网站设置了Content Security Policy，且该安全策略不允许执行unsafe-eval类型的脚本。 拿github的为例，其html的response header有这个字段content-security-policy，其值格式化之后如下： 1234567891011121314default-src 'none';base-uri 'self';block-all-mixed-content;connect-src 'self' uploads.github.com www.githubstatus.com collector.githubapp.com api.github.com github-cloud.s3.amazonaws.com github-production-repository-file-5c1aeb.s3.amazonaws.com github-production-upload-manifest-file-7fdce7.s3.amazonaws.com github-production-user-asset-6210df.s3.amazonaws.com cdn.optimizely.com logx.optimizely.com/v1/events translator.github.com wss://alive.github.com github.githubassets.com;font-src github.githubassets.com;form-action 'self' github.com gist.github.com;frame-ancestors 'none';frame-src render.githubusercontent.com render-temp.githubusercontent.com viewscreen.githubusercontent.com;img-src 'self' data: github.githubassets.com identicons.github.com collector.githubapp.com github-cloud.s3.amazonaws.com secured-user-images.githubusercontent.com/ *.githubusercontent.com customer-stories-feed.github.com spotlights-feed.github.com;manifest-src 'self';media-src github.githubassets.com;script-src github.githubassets.com;style-src 'unsafe-inline' github.githubassets.com;worker-src github.com/socket-worker-3f088aa2.js gist.github.com/socket-worker-3f088aa2.js 关于这些字段的意义参考文末的资料。大致明白浏览器的安全策略主要涉及到script、img、font、xhr、style、媒体文件等资源的来源域名，防止页面被第三方恶意插入不信任域名的代码。 我们的项目目前都是裸奔，至于这些设置能达到哪些程度上的安全，由于目前对web安全研究甚少，这块完全是盲点，打算认真啃下《Web前端黑客技术揭秘》这本书。 参考资料https://www.ruanyifeng.com/blog/2016/09/csp.html","link":"/2021/08/03/blogs/csp/"},{"title":"手写deepClone","text":"通过Object.prototype.toString判断 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657let mapObj = new Map();mapObj['key1'] = 1;mapObj['key2'] = 2;let obj = { a: 100, b: [10, 20, 30], c: { x: 10 }, d: /^\\d+$/, e: mapObj};let arr = [10, [100, 200], { x: 10, y: 20}];function deepClone(obj) { let newObj = {}; let type = Object.prototype.toString.call(obj).match(/\\[object\\s(\\w+)\\]/)[1]; if (type == 'Array' || type == 'Set') { newObj = []; for (const val of obj) { newObj.push(deepClone(val)); } } else if (type == 'Set') { newObj = new Set() for (const key of obj) { newObj.add(deepClone(obj[key])); } } else if (type == 'Object' || type == 'Map') { if(type == 'Map') newObj = new Map() for (const key in obj) { if (Object.hasOwnProperty.call(obj, key)) { newObj[key] = deepClone(obj[key]); } } } else { return obj; } return newObj;}let obj2 = deepClone(obj);let arr2 = deepClone(arr); // console.log(obj2)console.log(arr2)console.log(obj2)console.log('-----------')obj.e.key1 = 3console.log(obj2)console.log('-----------')arr[1][0] = 999console.log(arr2) 以上写法有个缺点是， 针对所有引用类型都要做判断，考虑的越周到，代码就越长 自定义类型 通过typeof判断 123456789101112131415function deepClone(obj) { // typeOf针对null值结果也是object，需要特殊处理 if (typeof obj != 'object') return obj if (obj == null) return obj if (obj instanceof RegExp) return new RegExp(obj) if (obj instanceof Date) return new Date(obj) let newObj = new obj.constructor; for (const key in obj) { if (Object.hasOwnProperty.call(obj, key)) { newObj[key] = deepClone(obj[key]); } } return newObj;} 以上方法需要注意: typeof针对null值结果也是object，需要特殊处理 typeof针对所有的引用类型结果都是object，需要特殊处理 偶然看到一个写的很全面的深拷贝方法：https://javascript.plainenglish.io/write-a-better-deep-clone-function-in-javascript-d0e798e5f550","link":"/2021/06/03/blogs/deep-clone/"},{"title":"flex上中下布局","text":"此文档只是说明如何实现，采用最新的弹性盒子布局规范，对旧写法不做考虑。 盒子组成12345678910&lt;body class=&quot;flex-ver&quot;&gt; &lt;div class=&quot;header red&quot;&gt;header&lt;/div&gt; &lt;div class=&quot;container flex-auto orange&quot;&gt; &lt;div&gt;content&lt;/div&gt; &lt;div&gt;content&lt;/div&gt; &lt;div&gt;content&lt;/div&gt; &lt;div&gt;content&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;footer blue&quot;&gt;footer&lt;/div&gt;&lt;/body&gt; 步骤步骤一：body元素设置为flex容器，纵向主轴1234.flex-ver { display: flex; flex-direction: column;} 步骤二：header和footer固定高度123456.header { height: 150px;}.footer { height: 100px;} 步骤三：主体区域container设置为占用剩余高度1234.flex-auto { flex-grow: 1; flex-basis: 0%;} 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./flex.css&quot;&gt;&lt;/head&gt;&lt;body class=&quot;flex-ver&quot;&gt; &lt;div class=&quot;header red&quot;&gt;header&lt;/div&gt; &lt;div class=&quot;container flex-auto orange&quot;&gt; &lt;div&gt;content&lt;/div&gt; &lt;div&gt;content&lt;/div&gt; &lt;div&gt;content&lt;/div&gt; &lt;div&gt;content&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;footer blue&quot;&gt;footer&lt;/div&gt;&lt;/body&gt;&lt;style&gt; .header { height: 150px; } .footer { height: 100px; } .flex-item { height: auto; } .flex { display: flex; flex-direction: row; } .flex-ver { display: flex; flex-direction: column; } .red { background: red; } .blue { background: blue; } .black { background: black; } .orange { background: orange; }&lt;/style&gt;&lt;/html&gt; 整体效果 主体内容高度自适应 底部footer位于文档最底部，即使主体区域高度不足以占满视口，footer依旧贴在底部。 兼容性火狐浏览器未能实现该效果，主体内容的高度根据内容自适应的，body的整体高度有可能低于视口高度。 解决火狐浏览器兼容性问题注意，html不要设置为overflow: hidden，要设置为overflow:visible。 12345678910html, body , div { padding: 0; margin: 0;}html { height: 100%;}body { min-height: 100%}","link":"/2019/05/10/blogs/flex-layout/"},{"title":"https密钥交换与数据传输","text":"https协议需要同事保证数据的私密性，也要保证完整性。也就是书，既要防止被解密，也要防止被篡改。 保证私密性私密性通过对称密钥加密来实现。所以，关键是要双方共享对称密钥（即下文的k），同时防止第三方拿到这个密钥。 双方共享对称密钥的过程即下图的“交换密钥”。 保证完整性虽然第三方没有办法解密截获的内容，但是它却可以对截获的内容进行篡改再发出去。https是如何做到识别篡改的呢？ https的加密算法含有消息认证机制。数字摘要是采用单项Hash函数将需要加密的明文“摘要”成一串固定长度（128位）的密文，这一串密文又称为数字指纹(fingerprint)，它有固定的长度，而且不同的明文摘要成密文，其结果总是不同的，而同样的明文其摘要必定一致。“数字摘要“是https能确保数据完整性和防篡改的根本原因。 所以只要对内容稍有改动，算出来的指纹就和原来的指纹不一样了，这样就可以知道内容已经被篡改过，不可信了。 所以，综上，双方是约定来一套机制验证数据的完整性，但是不能恢复被篡改的数据。","link":"/2020/10/02/blogs/https/"},{"title":"in 操作符","text":"用来判断对象中是否拥有某个属性。 使用场景for 循环12345let obj = {a: 1, b:2, c:3}for(let key in obj) { console.log(obj[key])} 判断是否有某个属性1234let obj = {a: 1, b:2, c:3}if('a' in obj) { console.log('obj has property &quot;a&quot;')} 和 hasOwnProperty的区别1in操作符可以判断所有可以通过点操作符访问到的属性，即可以访问对象本身以及原型链上的属性。hasOwnProperty只能判断实例拥有 的属性，不能判断原型链上的属性。 由于原型链上的属性是只读的，所以delete操作符只能删除属于对象本身的属性。","link":"/2020/03/20/blogs/in-operator/"},{"title":"判断浏览器是否是隐私模式","text":"很旧的版本较旧的版本，无痕模式禁用了FileSystem API。 123456789var fs = window.RequestFileSystem || window.webkitRequestFileSystem;if (!fs) { console.log(&quot;check failed?&quot;);} else { fs(window.TEMPORARY, 100, console.log.bind(console, &quot;not in incognito mode&quot;), console.log.bind(console, &quot;incognito mode&quot;));} 但是据说现在不能用了。 新一点的无痕模式下，TEMPORARY 存储配额较低。参考文章 123456789101112if ('storage' in navigator &amp;&amp; 'estimate' in navigator.storage) { const {usage, quota} = await navigator.storage.estimate(); console.log(`Using ${usage} out of ${quota} bytes.`); if(quota &lt; 120000000){ console.log('Incognito') } else { console.log('Not Incognito') } } else { console.log('Can not detect')} 但是个人使用chrome实践之后发现这个方法其实也不行，隐私模式下输出结果为： 1Using 0 out of 536504813 bytes. 现在的无痕模式看到stackoverflow的一个回答解释说，chrome76+的版本都不允许任何方式检测无痕模式。 看看现在chrome对无痕模式对解释： 在无痕模式下，您的浏览记录、Cookie、网站数据以及您在表单中输入的信息都不会保存到您的设备中。也就是说，您的活动不会显示在 Chrome 浏览器的历史记录中，因此与您共用设备的人不会看到您的活动。网站会将您视为新用户；只要您不登录，网站就无法确定您的身份。 localstorage和sessionStorage还是可以用的，只不过cookie不会保存。等下，cookie不会保存是什么概念，我们再看看： 每次您关闭所有无痕式窗口时，Chrome 都会舍弃与此浏览会话相关的所有网站数据和 Cookie。 也就是说，cookie用是可以用，但是窗口关闭的话不会保存。如果我们cookie的有效期不是session类型的，会受到影响。本来你的cookie设定7天后过期，结果今天用完关闭窗口cookie就没了。这样做也正是无痕模式的初衷，而且不影响使用。 总结现在的浏览器已经没有必要判断无痕模式了。目前的无痕模式的重点在于使用后不留下记录，不影响使用过程。","link":"/2019/03/07/blogs/incognito-mode/"},{"title":"linux常见命令","text":"查看端口占用情况 sudo netstat -apn | grep 80 最后一列可以看到进程号 查看ngin端口启用状态： ps -ef | grep nginx 查看端口进程上一步的进程号可以查出是哪个应用占用了端口 ps -ef | grep 3345 杀掉进程 sudo kill -9 3345 -9只是一个信号，表示强制终止，不管正在终止的进程在做什么 查看或编辑nginx配置12vi /usr/local/nginx/conf/nginx.confvi nginx.conf 重启服务器： /usr/local/nginx/sbin/nginx -s reload 连接远程服务器:ssh root@192.168.1.1 上传文件夹到远程目录：scp -r /usr/xxx root@192.168.1.1:/opt/project这个命令执行的结果是，xxx目录会存在于服务器project目录下 删除文件夹： rm -rf dist 移动所有文件到上一个目录： mv * ../ 查看当前目录： pwd 查看用户： cat /etc/passwd 查看用户组： cat /etc/group 查看用户属于哪个组： id root","link":"/2019/12/06/blogs/linux-command/"},{"title":"移动端meta","text":"viewport1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=yes,minimal-ui&quot;&gt; MobileOptimized告诉浏览器页面为某个宽度特殊优化 (微软系) 1&lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot; /&gt; HandheldFriendly告诉浏览器页面是否为手持设备优化，会被MobileOptimized覆盖 (旧浏览器和功能机上某些浏览器识别) 1&lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot; /&gt; Apple私有12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!-- iOS 设备 begin --&gt; &lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;标题&quot;&gt; &lt;!-- 添加到主屏后的标题（iOS 6 新增） --&gt; &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;/&gt; &lt;!-- 是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏 --&gt; &lt;meta name=&quot;apple-itunes-app&quot; content=&quot;app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL&quot;&gt; &lt;!-- 添加智能 App 广告条 Smart App Banner（iOS 6+ Safari） --&gt; &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;/&gt; &lt;!-- 设置苹果工具栏颜色 --&gt; &lt;meta name=&quot;format-detection&quot; content=&quot;telphone=no, email=no&quot;/&gt; &lt;!-- 忽略页面中的数字识别为电话，忽略email识别 --&gt; &lt;!-- 启用360浏览器的极速模式(webkit) --&gt; &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt; &lt;!-- 避免IE使用兼容模式 --&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt; &lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt; &lt;!-- 微软的老式浏览器 --&gt; &lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt; &lt;!-- uc强制竖屏 --&gt; &lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt; &lt;!-- QQ强制竖屏 --&gt; &lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt; &lt;!-- UC强制全屏 --&gt; &lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt; &lt;!-- QQ强制全屏 --&gt; &lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt; &lt;!-- UC应用模式 --&gt; &lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt; &lt;!-- QQ应用模式 --&gt; &lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt; &lt;!-- windows phone 点击无高光 --&gt; &lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt; &lt;!-- iOS 图标 begin --&gt; &lt;link rel=&quot;apple-touch-icon-precomposed&quot; href=&quot;/apple-touch-icon-57x57-precomposed.png&quot;/&gt; &lt;!-- iPhone 和 iTouch，默认 57x57 像素，必须有 --&gt; &lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;114x114&quot; href=&quot;/apple-touch-icon-114x114-precomposed.png&quot;/&gt; &lt;!-- Retina iPhone 和 Retina iTouch，114x114 像素，可以没有，但推荐有 --&gt; &lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;144x144&quot; href=&quot;/apple-touch-icon-144x144-precomposed.png&quot;/&gt; &lt;!-- Retina iPad，144x144 像素，可以没有，但推荐有 --&gt; &lt;!-- iOS 图标 end --&gt; &lt;!-- iOS 启动画面 begin --&gt; &lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;768x1004&quot; href=&quot;/splash-screen-768x1004.png&quot;/&gt; &lt;!-- iPad 竖屏 768 x 1004（标准分辨率） --&gt; &lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;1536x2008&quot; href=&quot;/splash-screen-1536x2008.png&quot;/&gt; &lt;!-- iPad 竖屏 1536x2008（Retina） --&gt; &lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;1024x748&quot; href=&quot;/Default-Portrait-1024x748.png&quot;/&gt; &lt;!-- iPad 横屏 1024x748（标准分辨率） --&gt; &lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;2048x1496&quot; href=&quot;/splash-screen-2048x1496.png&quot;/&gt; &lt;!-- iPad 横屏 2048x1496（Retina） --&gt; &lt;link rel=&quot;apple-touch-startup-image&quot; href=&quot;/splash-screen-320x480.png&quot;/&gt; &lt;!-- iPhone/iPod Touch 竖屏 320x480 (标准分辨率) --&gt; &lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;640x960&quot; href=&quot;/splash-screen-640x960.png&quot;/&gt; &lt;!-- iPhone/iPod Touch 竖屏 640x960 (Retina) --&gt; &lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;640x1136&quot; href=&quot;/splash-screen-640x1136.png&quot;/&gt; &lt;!-- iPhone 5/iPod Touch 5 竖屏 640x1136 (Retina) --&gt; &lt;!-- iOS 启动画面 end --&gt; &lt;!-- iOS 设备 end --&gt; format-detection禁用电话号码和邮箱识别 1&lt;meta name=&quot;format-detection&quot; content=&quot;telphone=no, email=no&quot; /&gt; 参考资料：移动端头部meta大全","link":"/2019/05/29/blogs/meta/"},{"title":"纯js实现打印功能","text":"打印其实最终都是调用window.print方法实现打印。只不过，我们通常不是打印整个页面，所以，诞生了各种各样的方法实现部分打印。适配vue框架的打印组件有vuePlugs_printjs和vue-print-nb。这两者实现的方式是一样的，都是使用iframe插入打印区域和对应样式。区别只是使用方式的区别。 那么，我也实现了一个原生js实现的打印功能。 一、新建iframe窗口为了打印出想要的部分，我们需要新建一个窗口，把需要的dom装进去。为了避免部分浏览器阻止窗口弹出导致无法打印，建议使用iframe。 打印的时候，我们需要防止iframe的显示影响页面布局，只需要在父页面设置iframe的样式为display: none即可。如下： 123const frame = document.createElement('iframe')frame.style.display = 'none'document.body.appendChild(frame) 二、选择需要打印的部分dom从当前dom选择需要打印的dom元素，插入iframe。 1234let target = document.getElementById('print-target')if (target) { frame.contentDocument.body.innerHTML = target.outerHTML} 三、插入样式一般情况下，你可以直接将父页面的style和link全部拷贝到iframe中，这样打印到样式和原本样式是一样的，除非打印部分的样式受未打印部分的父元素控制导致样式脱节，所以，打印部分的样式尽量和父元素解耦。 我们知道，浏览器打印的时候你可能需要不一样的样式，只需要加多一个style标签引入打印样式即可。比较典型的就是，打印的时候你想要按照需要打印的纸张尺寸打印，这时候可以在@media print中将容器的宽度改为打印尺寸（如A4是210mm，css支持mm单位的尺寸）。 四、特殊元素处理由于我们将打印区域拷贝到ifame中采用对的是将targetElement.outerHTML赋值给iframe的body的。这样赋值的情况下，部分表单组件会失去值，所以，我们需要在赋值之前将值固定，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041// https://github.com/Power-kxLee/vue-print-nb/blob/master/src/packages/printarea.jslet copy = ele.cloneNode(true);let copiedInputs = copy.querySelectorAll('input,select,textarea');let selectCount = -1;for (let i = 0; i &lt; copiedInputs.length; i++) { let item = copiedInputs[i]; let typeInput = item.getAttribute('type'); let copiedInput = copiedInputs[i]; // 获取select标签 if (!typeInput) { typeInput = item.tagName === 'SELECT' ? 'select' : item.tagName === 'TEXTAREA' ? 'textarea' : ''; } // 处理input框 if (item.tagName === 'INPUT') { // 除了单选框 多选框比较特别 if (typeInput === 'radio' || typeInput === 'checkbox') { copiedInput.setAttribute('checked', item.checked); // } else { copiedInput.value = item.value; copiedInput.setAttribute('value', item.value); } // 处理select } else if (typeInput === 'select') { selectCount ++; for (let b = 0; b &lt; ele.querySelectorAll('select').length; b++) { let select = ele.querySelectorAll('select')[b]; // 获取原始层每一个select !select.getAttribute('newbs') &amp;&amp; select.setAttribute('newbs', b) // 添加标识 if (select.getAttribute('newbs') == selectCount) { let opSelectedIndex = ele.querySelectorAll('select')[selectCount].selectedIndex; item.options[opSelectedIndex].setAttribute('selected', true); } } // 处理textarea } else{ copiedInput.innerHTML = item.value; copiedInput.setAttribute('html', item.value); }}","link":"/2019/08/20/blogs/print/"},{"title":"html property &amp; attribute","text":"propertyDOM元素的属性，如selectedIndex, tagName, nodeName, nodeType, ownerDocument, defaultChecked, defaultSelected DOM是提供给js访问页面元素的对象 attributeHTML标签上绑定的属性，包括id, value, name, type，除了value之外，其它属性基本都是字符串类型的 JQuery的attr()和prop()方法的区别prop()就是获取property属性的值，attr()是获取attribute的值如果要改变DOM的值，获取会发生变化的属性值，需要调用prop()方法，比如checked, selected, or disabled1&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot; /&gt; 对于以上标签，获取值对应关系如下： 123456elem.checked true (Boolean) Will change with checkbox state$( elem ).prop( &quot;checked&quot; ) true (Boolean) Will change with checkbox stateelem.getAttribute( &quot;checked&quot; ) &quot;checked&quot; (String) Initial state of the checkbox; does not change$( elem ).attr( &quot;checked&quot; ) (1.6) &quot;checked&quot; (String) Initial state of the checkbox; does not change$( elem ).attr( &quot;checked&quot; ) (1.6.1+) &quot;checked&quot; (String) Will change with checkbox state$( elem ).attr( &quot;checked&quot; ) (pre-1.6) true (Boolean) Changed with checkbox state","link":"/2018/07/03/blogs/property-attribute/"},{"title":"第99次学习原型链","text":"变量有基于类（构造函数）创建的，也有基于实例创建的。 简单类型有Number，Boolean，Null，Undefined，String，Symbol，RegExp引用类型：Array，Object，Function，Set，Map 字面量创建的变量12let a = [1,2,3]let b = {} 通过字面量创建的变量，底层会调用对应的构造函数，可以输出constructor属性看看：字面量生成的变量原型是是这些内置类型的构造函数。 构造函数创建的变量通过new创建的变量，调用构造函数本身，所以原型的constructor就是这个构造函数。 12345function MyClass(name) { this.foo = name}let myObj = new MyClass('bar') myObj格式如下：myObj.constructor取的是__proto__.constructor Object.create该方法比较特殊，会通过现有的对象实例创建新对象，新对象的原型是旧实例，而不是类或者构造函数。 12let obj = {foo: 'bar'}let obj2 = Object.create(obj) 打印obj2 可见，obj2.__proto__没有constructor属性，所以obj2.constructor会继续往上级寻找该属性，所以，obj2.constructor的值为Object函数 js类继承一、改变this指向 call实现构造函数继承123456789101112131415function Parent(name,age) { this.name = name this.age = age}Parent.prototype.say = function () {}function Child (name,age) { Parent.call(this, ...arguments)}var c = new Child('joe', 12)c.name = 'joe'console.log(c.name);console.log(c.say); 该方法只是通过将子类的this指向父类的构造函数并调用。仅仅是继承了父类的既有属性，并没有继承原型对象。 实现call12345678910111213141516var a = 1function fn () { console.log(this.a)}fn() // 非严格模式：1 严格模式 ：Uncaught TypeError: Cannot read property 'a' of undefinedvar obj = { a: 11}Function.prototype.myCall = function (context = window, ...args) { context.fn = this let res = context.fn(...args) delete context.fn return res}fn.myCall(obj) // 1 call方法做的事情很简单，就是将函数挂到传入的对象上，这样通过属性调用执行函数时this自然就会指向对象。 this为什么是实例老生常谈this的指向 函数中的this，不会像变量一样从父级作用域查找。函数中this直接指向window，严格模式下为undefined，除非有通过call或者apply重新绑定this。 函数作为对象属性时，this指向的是对象 new后面的构造函数、实例方法调用，this指向都是实例 直接调用构造函数的原型方法，this指向当然是原型对象啦（这个函数是哪个对象调用的，this指的就是这个对象） 实现myNew123456789101112131415161718function Parent(name,age) { this.name = name this.age = age}Parent.prototype.say = function () {}function Child (name,age) { Parent.call(this, ...arguments)}function myNew (fn, ...args) { var obj = { __proto__: fn.prototype } var res = fn.apply(obj, ...args) return typeof res === 'object' ? res : obj}myNew(Child, 'joe') 二、原型链也要继承先把基本代码写上： 123456789101112function Parent(name,age) { this.name = name this.age = age}Parent.prototype.say = function () { console.log('say hello');}function Child (name, age, classNumber) { Parent.apply(this, arguments) this.classNumber = classNumber} 下面说一下Child如何继承Parent 原型链。 Child.prototype = new Parent()12345Child.prototype = new Parent()var c = new Child('joe', 12, 3)console.log(c.name); // joec.say() 这个方法，有个缺点，就是Parent函数执行了2次，一次是给Child.prototype赋值，一次是Child实例化。而且Child.prototype上会挂上多余的name和age属性。 Child.prototype = Parent.prototype1234Child.prototype = Parent.prototypevar c = new Child('joe', 12, 3)console.log(c.name); // joec.say() 这个方法，Child和Parent共用了原型对象，当我们想给Child的原型对象上增加Child专属的方法（如study）时，会导致Parent.prototype也会被同时修改。 Child.prototype = Object.create(Parent.prototype)1234Child.prototype = Object.create(Parent.prototype)Child.prototype.study = function(){ console.log('go school')} Object.create通过拷贝一份prototype可以解决第二种方法的问题。 prototype.constructor属性现在指向Parent函数。但是new Child语法会自动执行Child函数，而不是直接执行Parent。而且instanceof也能通过验证 12var c = new Child('joe', 12)c instanceof Child // true 这一点超出预料，尽管从浏览器的输出结果，并没有找到Child的影子：看来，Child.prototype.constructor = Child似乎不是很有必要。 加上constructor我还是要说，加上这句话：1Child.prototype.constructor = Child why? 如果原型对象使用了this.constructor之类的语法，那它拿到的就是Parent: 1234567891011121314151617181920// define the Person Class function Parent(name) { this.name = name;} Parent.prototype.copy = function() { return new this.constructor(this.name);}; // define the Student class function Child(name) { Parent.call(this, name);} // inherit Person Child.prototype = Object.create(Parent.prototype);var child1 = new Child(&quot;trinth&quot;); console.log(child1 instanceof Child); // =&gt; trueconsole.log(child1.copy() instanceof Child); // =&gt; false 总之构造函数要像上面那张构造函数-原型对象-实例关系图一样完完整整。 类型判断判断变量类型有多种方法，下表列出了这些方法的完整功能范围：","link":"/2021/06/04/blogs/prototype/"},{"title":"proxy 与 reflect","text":"Proxy定义 在目标对象上架设一个拦截层， 外界对该对象的访问先经过这一个拦截层，这个拦截层可以对外界对访问进行过滤和改写。翻译为代理器。 举个拦截和改写例子： 12345678let proxy = new Proxy({}, { get: function() { return 35 }})proxy.time // 35proxy.name // 35 上面对代码拦截了一个空对象的属性getter。只要是需要访问到对象的属性，都会触发getter。 Proxy 能拦截哪些访问行为呢？ 拦截行为 触发条件 返回值说明 get(target, propKey, receiver) 读取对象属性，proxy.foo，proxy[‘foo’] 返回属性值 set(target, propKey, value, receiver) 设置对象属性，proxy.foo = v，proxy[‘foo’] = v 返回一个布尔值，表示是否设置成功 has(target, propKey) propKey in proxy的操作 返回一个布尔值，表示是否包含此属性 deleteProperty(target, propKey) delete proxy[propKey] 返回一个布尔值，表示是否删除成功 ownKeys(target) Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in循环 返回目标对象所有自身的属性的属性名 getOwnPropertyDescriptor(target, propKey) Object.getOwnPropertyDescriptor(proxy, propKey) 返回属性的描述对象 defineProperty(target, propKey, propDesc) Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs) 返回一个布尔值表示是否定义成功 preventExtensions(target) Object.preventExtensions(proxy) 返回一个布尔值表示是否定义成功 getPrototypeOf(target) Object.getPrototypeOf(proxy) 返回一个对象（对象原型） isExtensible(target) Object.isExtensible(proxy) 返回一个布尔值 setPrototypeOf(target, proto) Object.setPrototypeOf(proxy, proto) 返回一个布尔值 apply(target, object, args) 拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…) 无限制 construct(target, args) 拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args) 返回实例对象 Reflect定义 将Proxy支持的代理方法一一对应到Reflect，方便在Proxy中使用原对象的默认行为。 12345678910let proxy = new Proxy(target, { set: function(target, name, value, receiver) { var success = Reflect.set(target, name, value, receiver); if (success) { console.log('property ' + name + ' on ' + target + ' set to ' + value); } return success; }});proxy.a = 1 某些方法和Object原型方法行为高度一致，所以，除了在Proxy中使用，还可以单独使用。 1234567891011121314// 老写法try { Object.defineProperty(target, property, attributes); // success} catch (e) { // failure}// 新写法if (Reflect.defineProperty(target, property, attributes)) { // success} else { // failure} 谁在用Vue设置内置属性只读设置内置keyCode为只读： 123456789101112131415161718const hasProxy = typeof Proxy !== 'undefined' &amp;&amp; Proxy.toString().match(/native code/) if (hasProxy) { const isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact') config.keyCodes = new Proxy(config.keyCodes, { set (target, key, value) { if (isBuiltInModifier(key)) { warn(`Avoid overwriting built-in modifier in config.keyCodes: .${key}`) return false } else { target[key] = value return true } } }) } 1Vue.config.keyCodes.ctrl = 86 以上代码会报错： 测试框架和defineProperty什么关系？什么时候适合用？","link":"/2020/03/15/blogs/proxy-reflect/"},{"title":"正向代理和反向代理的区别","text":"正向代理位于客户端和服务器之间的代理服务器，对服务器不可见。 客户端可以访问该代理服务器，但是客户端不直接访问代理背后的服务器，或者客户端根本没办法访问代理背后的服务器。 客户端需要明确指定代理服务器的地址。以及可能需要身份认证来限制其它客户端随意访问。 正向代理比较常见的使用场景是翻墙，局域网抓包。 反向代理隐藏于服务器背后，对客户端不可见 客户端访问的服务器本身就是反向代理服务器，只是客户端不知情。反向代理服务器将客户端的请求代发给其背后的服务器，拿到结果并传回给客户端。 反向代理比较常见的场景是本地代码调试线上接口，表面访问本地接口，但是由本地反向代理服务器将接口转发到线上地址以解决接口跨域问题。另外一个常用的场景是服务器负载均衡，以及外网灰度发布。 外网灰度发布举个例子，反向代理负责将请求转发给3个服务器，这3个服务器上的代码有一个是旧版本，另外2个是新版本。代理服务器将某些ip段客户端的请求转发给旧版本，其它的转发给新版本。这样就可以达到灰度发布的效果。","link":"/2020/03/17/blogs/proxy/"},{"title":"有趣的正则表达式","text":"字符串拼接假设有这样一种场景： 有三个字符串类型的变量，姓名(name)，性别(sex)，年龄(age)。想把这三个变量值用逗号拼接成1个字符串userInfo。 常规的方法可能就是类似这样： 1let userInfo = `${name}，${sex}，${age}` 问题是，这三个变量可能都为空。你肯定不希望userInfo是”，，10”或者”小明，，10”或者”，，” 简单的思考后你可能会这样做： 1234let userInfo = ''name ? userInfo += name + '，' :sex ? userInfo += sex + '，':age ? userInfo += age + '，': 本着足够懒的想法，仔细考虑了一番之后，我总结出的规律就是： 开头结尾的连接符删除 中间有2个或以上的连接符都要删减至1个 所以可以这样写： 1let userInfo = `${name}，${sex}，${age}`.replace(/(^，)|(，$)/g, '').replace(/，{2,}/, '，')","link":"/2019/04/16/blogs/regexpression/"},{"title":"说一说自己设计的运营后台权限","text":"权限设计我们的运营后后台的用户由多个角色组成。不同角色的使用权限区别在于： 可见的菜单不同 同一个菜单页面内可见的操作按钮不同，如是否存在编辑按钮 页面内的操作按钮可能对应着其它不在菜单内显示的路由，如编辑页面 根据以上分析，我们可以提炼出3个关键词： 菜单 路由 权限 3者之间的关系我们再捋一捋。 从顶级菜单开始，每个菜单是树状结构，每个叶子节点对应一个路由，这个路由是由1个或多个权限决定的（如查看或编辑权限任意一个存在就决定这个路由的存在）。 除了每个菜单的叶子节点对应一个路由之外，有些路由是隐藏在操作中的，和某些操作权限相关。 有些权限仅控制页面内操作，和任何路由无关。 根据以上分析，可以构思出这3个关键词的结构： 根据上图可知，权限可以有2种行为： 控制路由 控制界面 服务端维护一份菜单，菜单的字段如下： 12345{ menu_code: '', // 唯一标识 menu_name: '', // 菜单名称 p_menu_code: '', // 父级菜单} 以上结构可以维护一份菜单树。 另外维护一份路由，字段如下： 12345{ route_code: '', // 唯一标识 route_path: '', // 客户端路由路径 menu_code: '', // 关联的菜单（为空表示不显示在菜单栏，通过某操作可以跳转）} 另外最重要的是权限，字段如下： 12345{ auth_code: '', // 唯一标识 auth_name: '', // 权限名称 route_codes: [], // 关联的路由列表（若为空，表示该权限只影响界面按钮）} 如果想要在配置的时候通过菜单分类显示权限，就需要通过菜单反查对应权限，因此需要反向维护关联关系，即 菜单表要关联路由 路由表关联权限 菜单表： 123456{ menu_code: '', // 唯一标识 menu_name: '', // 菜单名称 p_menu_code: '', // 父级菜单, relate_route: [] // 关联的路由} 路由表： 123456{ route_code: '', // 唯一标识 route_path: '', // 客户端路由路径 menu_code: '', // 关联的菜单 relate_auth: [] // 关联的权限列表} 实现权限配置以顶级菜单分类显示可配置的路由： 123456789101112- 用户管理 —— 用户查看 —— 用户新增/编辑- 商品管理 —— 商品查看 —— 商品添加/编辑基本信息 —— 商品价格日历修改 —— 商品上下架- 订单管理 —— 订单查看 —— 订单操作退款 —— 财务结算 通过菜单的反向的关联关系，可以分类显示所有可配置的权限。将选中的权限列表提交后，每个角色有一份自己的权限表。 C端实现1. 登录接口返回该用户所属角色对应的权限表、路由表，树结构的菜单 权限表用于界面内操作控制 路由表用于注册有权限的路由 树结构的菜单用来初始化菜单栏 2. 动态注册路由路由分为3种，默认路由、重定向路由、受权限控制路由。 12345678910111213141516171819202122232425262728293031323334353637383940// 默认路由export const defaultRootes = [ { path: '/login', // component: login components: { login: () =&gt; import(/* webpackChunkName: &quot;base&quot; */'@/views/login') } }, { path: '/loading', // component: loading component: () =&gt; import(/* webpackChunkName: &quot;base&quot; */'@/components/bodyView/components/loading') }]// 重定向路由export const redirectRoutes = [ { path: '/', // 默认重定向路由（登录后根据权限修改） redirect: '/login' }, { path: '*', // component: notFound component: () =&gt; import(/* webpackChunkName: &quot;base&quot; */'@/components/bodyView/components/404') }]// 受权限控制路由export const routes = [ { path: '/order/list', // component: orderList component: () =&gt; import(/* webpackChunkName: &quot;order&quot; */'@/views/order') }, ...] 关于重定向，有2个细节需要注意： 根路由’/‘的重定向路由是不固定的。 在登录前，’/‘的重定向路由是’/login’ 成功登录后，需要取出第一个菜单下的第一个路由作为重定向路由。 已登录用户的”/login”路由需要重定向到首页 在App.vue中注册默认路由： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546created() { this.path = this.$route.path // 注册基本路由 this.$router.addRoutes([...defaultRootes, ...redirectRoutes]) // 检查登录状态 this.checkLogin()},methods: { checkLogin() { // 通过获取用户信息判断是否已经登录 apiGetUserInfo().then((response) =&gt; { /* 已登录 */ // 1. 保存用户信息 // 2. 初始化菜单 this.menus = response.data.menus // 3. 注册路由 const routes = response.data.routes // 将根路由'/'的重定向路由改为接口返回的第一个路由： redirectRoutes[0].redirect = routes[0].path const newRouter = new Router({ mode: 'history' }) // @ATTENTION: 执行到此处时需要重写matcher以覆盖之前注册的路由，因为addRoutes无法覆盖旧的重复路由，且官方不支持deleteRoutes方法 this.$router.matcher = newRouter.matcher this.$router.addRoutes(defaultRootes.concat(filteredRoutes, redirectRoutes)) // 4. 登录后路由跳转 if (this.path.indexOf('/login') &gt;= 0) { // 登录路由跳转到首页 this.$router.replace('/') } else { let path = this.$route.fullPath // 需要有路由变化才能重新加载此前未注册的路由 this.$router.replace('/loading') this.$router.replace(path) } // 4. 保存权限列表 this.auths = response.data.auths }).catch(() =&gt; { // 未登录，跳转到登录页面 this.goLogin() }) }} 3. 登录过期处理接口拦截器监测到token失效等鉴权失败等错误时，提示并跳转到登录页： 12345678910Vue.prototype .$confirm('登录失效，请重新登录', '提示', { confirmButtonText: '确定', cancelButtonText: '取消', type: 'warning' }).then(() =&gt; { router.push('/login') }).catch(() =&gt; { router.push('/login') })","link":"/2019/03/02/blogs/role-auth-design/"},{"title":"base64字符串保存","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script&gt;//方法1function saveAsLink(base64Str) { var a = document.createElement('a'); // 转换完成，创建一个a标签用于下载 a.download = fileName; a.href = 'data:application/msword;base64,' + base64Str; a.style.display = 'none'; document.body.appendChild(a) // 修复firefox中无法触发click a.click(); document.body.removeChild(a)}saveAsLink(fileBse64Str)//方法2(firefox浏览器不兼容)var blob = new Blob([_base64ToArrayBuffer(fileBse64Str)], {type: 'application/msword'}), fileName = '文件名称.doc'function _base64ToArrayBuffer(base64) { var binary_string = window.atob(base64); var len = binary_string.length; var bytes = new Uint8Array( len ); for (var i = 0; i &lt; len; i++) { bytes[i] = binary_string.charCodeAt(i); } return bytes.buffer;}function downFile(blob, fileName) { if (window.navigator.msSaveOrOpenBlob) { navigator.msSaveBlob(blob, fileName); } else { var link = document.createElement('a'); debugger link.href = window.URL.createObjectURL(blob); link.download = fileName; link.click(); window.URL.revokeObjectURL(link.href); }}downFile(blob, fileName)&lt;/script&gt;&lt;/html&gt;","link":"/2020/05/08/blogs/save-base64/"},{"title":"防抖和节流","text":"防抖短时间内连续触发的事件，不执行回调，给定一个冷却时间，这段时间内没有触发则时间结束后执行回调。即，持续触发不执行，不触发一段时间之后再执行。 常见场景： 输入框持续输入，输入内容远程查询 多次触发点击事件 滚动后获取滚动距离 12345678910const debounce = function (func, delay) { let timer = null return function() { clearTimeout(timer) timer = setTimeout(() =&gt; { func(...arguments) }, delay || 300) }} 节流函数一段时间内只执行一次。即，持续触发并不会执行多次，到一定时间再去执行。通过闭包保存开关状态。常见场景： 自定义滚动条 页面resize 12345678910111213141516const throttle = function (func, delay) { let run = true return function () { if (!run) { // 如果开关关闭了，那就直接不执行下边的代码 return } // 持续触发的话，run一直是false，就会停在上边的判断那里 run = false func(...arguments) // 定时器到时间之后，会把开关打开，我们的函数就会被执行 setTimeout(() =&gt; { run = true }, delay) }} 以上方法使用的时候需要注意，由于返回的是函数，所以throttle或debounce只能调用一次。以Vue为例： 12345678910111213onPageScroll(e) { if (!this.$options.throttleFunc) { this.$options.throttleFunc = throttle((scrollTop) =&gt; { if(scrollTop &gt; 30) { this.scrollStatus = true } else { this.scrollStatus = false } }, 100) } this.$options.throttleFunc(e.scrollTop)} 参考资料:知乎：函数的防抖和节流是个啥？？？","link":"/2021/05/31/blogs/throttle-debounce/"},{"title":"纯css实现优惠券样式","text":"核心知识点： radial-gradient实现优惠券卡片左右2边的缺角 background可以叠加多个效果 12345&lt;div class=&quot;ticket&quot;&gt; · 海外留学项目最高立减&lt;span&gt;5000&lt;/span&gt;元现金 &lt;br&gt; · 语言培训项目最高立减&lt;span&gt;2000&lt;/span&gt;元现金 &lt;br&gt; · 国际部项目最高三年&lt;span&gt;全额奖学金&lt;/span&gt;现场发放&lt;/div&gt; 1234567891011121314151617.ticket{ width: 3.45rem;//内容层的宽度 height: 1.14rem;//内容层的高度 margin: 0 auto; box-sizing: border-box; padding: 0.25rem 0.3rem;font-size: 0.15rem; line-height: 1.5; color: #fff; background: radial-gradient(circle at 0 0.57rem, transparent 0.15rem, #ffbcbe 0.06rem) top left, linear-gradient(0.25turn, #ffbcbe, #000), radial-gradient(circle at 0.17rem 0.57rem, transparent 0.15rem, #000 0.16rem) bottom right; background-size: 0.17rem 1.14rem, 2.95rem 1.14rem, 0.17rem 1.14rem; background-size: 0.17rem 1.14rem, 2.95rem 1.14rem, 0.17rem 1.14rem; background-repeat: no-repeat; background-position: 0.1rem 0px,0.26rem 0px,3.2rem 0px;}.ticket span{ color: #eb6877; text-decoration: underline;}","link":"/2020/05/03/css/css-coupon/"},{"title":"凹槽样式小结","text":"border-radius由于border-radius的最大半径是50%，无法直接实现大弧度。独立一个元素，使其尺寸是容器的1倍以上，再通过平易即可实现视觉上的凹槽效果。 123456789101112131415161718&lt;!--html--&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;curved-bg&quot;&gt;&lt;/div&gt;&lt;/div&gt;// css.container { width: 300px; height: 300px; overflow: hidden;}.curved-bg { width: 300%; height: 300%; margin-top: -250%; margin-left: -100%; border-radius: 50%; background-color: rgba(0, 0, 0, 0.3);} 以上方法只是对一个简单的背景做圆角处理。试想以下这样的场景：圆弧部分只是一个修饰，图片部分的轮播图可响应点击交互，如下图banner底部的大圆弧。 针对这样的场景，border-radius方法依旧可以用，只不过需要用到pointer-event:none实现点击穿透。该属性绝大部分浏览器目前都支持。 切图最简单的办法，就是将有弧度的部分切成一张png图盖在banner下方，由于这一个区域的高度较浅，不影响点击交互。 curved border-radius可以通过椭圆圆角实现： 123456789101112131415161718&lt;!--html--&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;curved-bg2&quot;&gt;&lt;/div&gt;&lt;/div&gt;// css.container { width: 300px; height: 300px; overflow: hidden;}.curved-bg2 { height: 100%; margin-top: -50%; background-color: rgba(0, 0, 0, 0.3); /* Curved corners */ border-bottom-left-radius: 50% 10%; border-bottom-right-radius: 50% 10%;} 利用了border-radius的裁剪形状。具体参考border-top-left-radius 以上2种方法渲染结果对比： 前者的效果两端较为平缓，而curved border-radius的两端比较陡峭，接近于垂直。视觉上curved border-radius效果一般。 radio-gradient用一个mask元素盖在banner上层，使用径向渐变，结合pointer-event:none实现点击穿透。 123456789101112131415.mask { position: absolute; width: 500px; height: 500px; left: 0; top: 0; background: #fff; background: radial-gradient(ellipse closest-side at center, transparent 919rpx, #fff 920rpx); background-size: 100px 500px; background-position: -891rpx -456rpx; background-repeat: no-repeat; pointer-events: none;} ellipse表示形状为椭圆。 椭圆怎么定义边界呢？ farthest-corner、closest-side 、closest-corner 、farthest-side。 closest-side表示background-size指定的背景画布的4条边，水平和垂直方向各自距离椭圆圆心最近的边和这个椭圆边界相切。farthest-side同理。 closest-corner首先选择最近的角，作为椭圆和画布边缘的相交点1，然后再在该角的2个邻边分别做相交点1的对称角，称为相交点2和相交点3。有了椭圆圆心，i以及3个交点，可以唯一确定一个椭圆的形状。这一点在很多网站上都没有讲清楚，经过实践总结出来的规律。 除了farthest/closest、side/corner组成的关键字之外。可以具体定义水平和垂直的半径。 center表示椭圆的圆心在background-size界定的范围中的相对位置。 在给颜色标注位置时，如果是具体数值而不是百分比，则数值是以椭圆水平方向的半径为最大值，MDN有个专业词Virtual gradient ray，翻译为虚拟渐变射线： 12&lt;p&gt;&lt;strong&gt;closest-side：&lt;/strong&gt;&lt;/p&gt;&lt;div id=&quot;grad1&quot;&gt;&lt;/div&gt; 123456#grad1 { height: 150px; width: 300px; background-color: red; /* 浏览器不支持的时候显示 */ background-image: radial-gradient(closest-side at 50% 50%, red 70px, yellow 80px, black 150px); } 水波纹效果在寻找方案的时候看到了一个有意思的水波纹。 实现原理就是多个方形容器旋转。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;div class=&quot;wave&quot;&gt; 水波纹效果 &lt;div class=&quot;wave1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;wave2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;wave3&quot;&gt;&lt;/div&gt;&lt;/div&gt;.wave{ position: relative; border: 1px solid silver; width: 100px; height: 100px; border-radius: 50%; line-height: 50px; margin: 0 auto; font-size: 14px; text-align: center; overflow: hidden; animation: water-wave linear infinite;}.wave1{ position: absolute; top: 40%; left: -25%; background: #33cfff; opacity: .7; width: 200%; height: 200%; border-radius: 40%; animation: inherit; animation-duration: 5s;}.wave2{ position: absolute; top: 40%; left: -35%; background: #0eaffe; opacity: .7; width: 200%; height: 200%; border-radius: 35%; animation: inherit; animation-duration: 7s;}.wave3{ position: absolute; top: 50%; left: -35%; background: #0f7ea4; opacity: .3; width: 200%; height: 200%; border-radius: 33%; animation: inherit; animation-duration: 11s;}@keyframes water-wave{ 0% {transform: rotate(0deg);} 100% {transform: rotate(360deg);}}","link":"/2021/06/02/css/curved-radius/"},{"title":"纯css实现行内标签","text":"有一个需求要实现下图的布局效果： 商品标签和商品标题融合在一起。 float元素一想到文字环绕，一开始想到的就是float。 彩色标签使用float:left 文字使用inline或者block 文字为什么不能用inline-block呢？ 12345678910111213&lt;style&gt; .left { float: left; color: red; } .right { display: inline-block; }&lt;/style&gt;&lt;div class=&quot;page&quot;&gt; &lt;div class=&quot;left&quot;&gt;特别长特别长&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;特别长特别长特别长特别长特别长特别长特别长特别长特别长特别长特别长特别长特别长特别长特别长特别长特别长特别长特别长特别长特别长特别长特别长特别长特别长特别长特别长特别长特别长特别长特别长特别长特别长特别长特别长特别长特别长特别长特别长特别长特别长特别长&lt;/div&gt;&lt;/div&gt; 结果： 可见，float:left和display:inline-block并列时，后者会换行。MDN解释说float意味着使用块布局。用这句话解释上面的情况说得过去。 但是，如果把right改成下面这样： 123456.right { display: block; &lt;!--或者--&gt; display: inline;}&lt;/style&gt; 就会变成 看来float意味着使用块布局这一点还要结合float本身是被用来设计文字环绕的说法结合才能解释的通float的行为。 实现文字环绕关于文字环绕使用inline还是block呢？ 如果想用inline，text-align就不生效。有2个选择： text-align作用到父元素 使用文字使用block+text-align 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt;&lt;div class=&quot;product-item-title&quot;&gt; &lt;span class=&quot;category-tag&quot;&gt;{{product.categoryName}}&lt;/span&gt; &lt;span class=&quot;product-name&quot;&gt;{{product.productName}}&lt;/span&gt;&lt;/div&gt;&lt;/template&gt;&lt;style lang=&quot;less&quot;&gt;// 方法1.product-item-title{ text-align: justify; .category-tag { float: left; // 高度和位置可能需要微调 // ... } .product-name { line-height: 40rpx; }}// 方法2.product-item-title{ .category-tag { float: left; // 高度和位置可能需要微调 // ... } .product-name { display:block; line-height: 40rpx; text-align: justify; }}&lt;/style&gt; 多行省略的文字环绕如果需求再升级： 多行省略使用了box布局： 123456789/*多行溢出显示省略*/.muti-line-ellipsis(@row: 2){ -webkit-line-clamp: @row; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; white-space: pre-wrap!important;} 采用前面的方法1，将muti-line-ellipsis作用在product-item-title上，在小程序上有问题，h5没问题。 采用前面的方法2，将muti-line-ellipsis作用在product-name上，在小程序上有问题，h5没问题。 二者均没有文字环绕效果，看来float:left的方法需要弃用了。 inline研究了下，发现，其实多个inline元素也是可以实现文字环绕效果的，因此有了接下来的最佳实践： 123456789101112131415161718192021222324&lt;template&gt;&lt;div class=&quot;product-item-title&quot;&gt;&lt;spanclass=&quot;category-tag&quot;&gt;{{product.categoryName}}&lt;/span&gt;&lt;spanclass=&quot;product-name&quot;&gt;{{product.productName}}&lt;/span&gt;&lt;/div&gt;&lt;/template&gt;&lt;style lang=&quot;less&quot;&gt;.product-item-title{ text-align: justify; -webkit-line-clamp: 3; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; white-space: pre-wrap!important; .category-tag { } .product-name { }}&lt;/style&gt; 需要注意的是，product-item-title内、元素之间不能有换行，否则行内元素就不能在同一行了。效果如下：","link":"/2020/06/18/css/inline-tag/"},{"title":"margin-bottom在ios设备的失效问题","text":"以下代码，html和body高度都是100%。子元素son被内容撑开高度。 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;son&quot;&gt; The footer is fixed at the bottom and supossed to revealed with the scrolling, so the previous section has a margin-bottom but it doesn't work, only in Safari. Everywhere else is ok, even in I.E. I tried to add overflow: auto in the page-wrapper, but everything gets weird in all browsers with elements dissapear and appear. I also have read that removing height: 100% in the body and html may fix that, but that is not an option for me, because i need the images to fix the browser height. // ...请填充内容至超出一屏高度 &lt;/div&gt; &lt;style&gt; html, body { height: 100%; margin: 0; padding: 0; } .son { margin-bottom: 100px; background-color: cyan; } &lt;/style&gt;&lt;/body&gt;&lt;/html&gt; 当内容不超过整屏时，通过审查元素可以看到margin存在。 当内容超过整屏时（包含margin）,在ios设备中，页面最底部盒子元素的margin-bottom会失效（safari和chrome浏览器都实效）。 如果把html和body的高度删除： 1234html, body { margin: 0; padding: 0;} 就正常了。 如果改成超出一屏的固定高度，会怎么样呢？ 12345html, body { height: 1000px; margin: 0; padding: 0;} 发现margin还是未生效。 因此，对盒子模型的margin折叠行为在ios设备上的表现作出以下猜测： 当元素属于页面最后一个子元素时，margin-bottom就会一层一层的渗透到祖先元素，直到html为止。当html高度固定时，子孙元素塌陷出来的margin不会影响它的滚动高度。 解决办法： 方案1:不固定html和body的高度，可以只设置min-height:100%。让其被内容自然撑开。 方案2:在body内加一个BFC容器，这样就可以防止margin塌陷到外层： 123456789101112131415161718192021&lt;body&gt;&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;son&quot;&gt; // ... &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;style&gt;html, body { height: 100%; margin: 0; padding: 0;}.parent { overflow-y: scroll;}.son { margin-bottom: 100px; background-color: cyan;}&lt;/style&gt; 理论上可以直接将body变为BFC，或者给body加个padding-bottom，但是实际上并无效果。因此需要在body内加多一层容器使其成为BFC。","link":"/2021/08/01/css/margin-bottom-ios/"},{"title":"white-space属性值表现","text":"属性值 换行符 空格和制表符 文字换行 行尾空格 normal 当作空白符，连续合并 连续合并 自动换行 删除 nowrap 当作空白符，连续合并 连续合并 不自动换行 删除 pre 保留，遇到即换行 保留 不自动换行 保留 pre-wrap 保留，遇到即换行 保留 自动换行 挂起 pre-line 保留，遇到即换行 连续合并 自动换行 删除 break-spaces 保留，遇到即换行 保留 自动换行 换行","link":"/2021/07/07/css/white-space/"},{"title":"nuxt导航共用","text":"导航作为多个页面之间共用的部分，一般是动态的，即每个页面返回之前需要异步请求。 服务端异步请求的方法有asyncData，fetch。但是这俩方法都只支持页面组件，不支持layout中使用。 所以，我们只能用vuex作为中转站，将页面组件获取的导航信息存储到vuex中。layout再从vuex中获取。 layout/default 1234567891011121314import navigator from '@@/navigator/index.vue'export default { name: 'Music163', components: { navigator }, data () { return { } }, computed: { menus () { return this.$store.state.menu.menus } }} pages/index 12345export default { fetch ({ store, params }) { store.dispatch('menu/GET_MENU') }} store/menu 123456789101112131415161718192021export const state = () =&gt; ({ menus: []})export const mutations = { SET_MENU (state, menus) { state.menus = menus }}export const actions = { GET_MENU (store, menus) { const data = [{ title: '发现音乐' }, { title: '我的音乐' }] store.commit('SET_MENU', data) }}","link":"/2020/01/20/nuxt/navigator/"},{"title":"charles 重写请求","text":"charles 和fiddler既然都可以拦截返回体，没有理由不可以拦截请求是不是？ 我这里只说charles吧。 配置重写域名 进入菜单 Tools -&gt; Rewrite 可见如下界面 点击sets 区域的Add按钮添加重写任务。 在右侧的Locations区域点击Add按钮添加需要重写的请求的域名 配置域名下的重写规则 选中上一个步骤中添加的域名，在Rules区域点击Add按钮 在Type项那里选择重写类型 有以上几种类型可供选择。从上图可以看出来，重写规则可以重写请求头部和请求体，也可以重写返回头部和返回体。 这个功能不仅能调试身份认证信息，还能调试跨域网站，以及接口数据。 在Match和Replace区域配置重写规则 上图将请求头部uniType的值替换为105，仅当uniType的值为101的时候才替换。","link":"/2020/02/01/tools/charles-rewrite-header/"},{"title":"git 统计代码量","text":"1git log --format='%aN' | sort -u | while read name; do echo -en &quot;{\\&quot;name\\&quot;:\\&quot;$name\\&quot;,\\t&quot;; git log --author=&quot;$name&quot; --since='2021-04-01' --until='2021-06-30' --pretty=tformat: --numstat | awk '{ add += $1; subs += $2; loc += $1 + $2 } END { printf &quot;\\&quot;add\\&quot;: %s, \\&quot;remove\\&quot;: %s, \\&quot;result\\&quot;: %s}\\n&quot;, add, subs, loc }' -; done 以上方法有缺陷： 只能统计所有人在某个仓库下、特定分支、特定时间段的代码量，通常统计master 如果是多版本并行开发，若存在分支未合并到master的情况则统计不准确 需要统计者先拉取仓库到本地 代码量统计本身就是个比较不人性化的评估标准，先占个坑，如果真有看到有人写出一个完整的统计脚本或者自己有空就再说。","link":"/2021/07/07/tools/code-statistics/"},{"title":"抓包工具调试线上代码","text":"web应用代码混淆和压缩可以一定程度上缩短代码的请求时间，从而提高页面的访问体验，但是却不方便调试。这里教大家使用抓包工具调试线上代码。 以下方法假设你已经成功用fiddler或者charles代理你要调试的线上应用。 fiddler拦截客户端代码很久以前遇到一个线上问题，本地不能复现，而且还是手机浏览器环境，而且客户端报错日志找不到相关的问题。当时想到的调试方法就是使用fiddler修改返回的js代码，开启vconsole的debug模式查看页面报错信息。这个方法其实就是拦截返回js并正则匹配内容进行修改。 局部修改使用fildder可以拦截http返回内容并修改。 1.打开CustomRules.js点击fiddler的Rules=&gt;Customize Rules，FiddlerScript editor工具就会自动的打开CustomRules.js文件。 2.修改 OnBeforeResponse 函数假如，我想把http://my.example.com/index.html 资源返回代码中的”vconsole.debug = false”改为”vconsole.debug = true”，只需要在这个函数中插入一个if语句。可以这样写： 12345//判断Url内容中是否包含特定内容，针对这个Url进行下面的操作if (oSession.uriContains(&quot;my.example.com/index.html&quot;)) { oSession.utilDecodeResponse(); oSession.utilReplaceInResponse(&quot;vconsole.debug = false&quot;, &quot;vconsole.debug = true&quot;);} 这个方法比较难操作，毕竟你需要先找到要修改的代码，确保需要替换的内容是独一无二的，而且，如果想修改替换内容需要重新修改替换逻辑。更加简单粗暴的方法是直接下载代码下来，将这个资源代理到本地，想怎么修改就怎么修改。 fiddler将代码代理到本地1.找到你需要代理的请求 标黄的请求就是目标请求，拖拽到右侧的AutoResponse标签中 2.选中代理选项勾选右侧AutoResponse标签中的 Enable rules：开启重定向使规则生效，指的是代理到本地这个规则。 Umatched requests passthrough:不影响那些没满足我们处理条件的请求通过。 3.选择需要代理的到的本地文件上图右侧选中第一步拖进去的请求，并在右下角的Rule Editor中的第二个下拉框选择Find a file。此时会打开本地资源管理器要求你选择文件。 4.修改代码刷新页面修改上一步你选中的代码，保存之后刷新你要调试的页面，重新加载的资源就回变成你本地的资源。 charles拦截客户端代码设置map local在请求中找到需要调试的代码文件，右键，菜单中选择 Map Local弹窗中选择需要映射到的本地文件点OK即可。 重新请求对应的资源发现已经是本地的代码文件了。这时候可以随意的修改代理到的本地文件调试。 取消map在Tools-&gt;Map Local菜单下可以删除刚刚添加的map。","link":"/2020/02/02/tools/fiddler-debug-online/"},{"title":"git 常用命令","text":"本地代码新建远程仓库如果本地配置的ssh 是其它域名下的，比如说公司内网gitlab，但是你此时想要创建的仓库是github上的，那代码推到远程仓库的时候需要使用https协议，而不是ssh，不然的话身份认证会失败的。 1git@github.com: Permission denied (publickey). 远程：创建一个仓库， 假如链接为 1https://github.com/sharemeans/vue.git/ 本地：12345678cd my-vuegit initgit add .git commit -m &quot;项目初始化&quot;git remote add origin https://github.com/sharemeans/vue.git/// 根据提示输入账号密码，成功之后代码自动上传// 代码推送到远程 -u表示推送成功后自动建立本地分支与远程分支的追踪git push -u origin master 查看远程仓库地址1git remote -v 查看本地分支跟踪的远程分支1git branch -vv 基于远程分支A创建本地跟踪分支A1git checkout -b A origin/A 基于本地分支B创建本地分支A1git checkout -b A B 基于远程分支创建本地同名跟踪分支1git checkout --track origin/A 合并A 分支到当前分支，且所有冲突都采用A分支1git pull -s recursive -X theirs A 恢复被删除的stash 输出最近删除的stash1234git fsck --lost-found/*** dangling commit 42c7122df57f326a6e1e0498fb89af06ab521192*/ 从输出列表中找出需要恢复的id：1git stash apply 42c7122df57f326a6e1e0498fb89af06ab521192 重命名当前分支123// 重命名为maingit branch -m maingit branch -M Main 打tag 切换到要打tag的分支 基于某个commit打tag1git tag -a [tagname] -m [tagmessage] 提交tag到远程1git push origin [tagname] 提交所有tag到远程123git push origin --tags// 或者git push --tags 删除tag1234// 第一步：删除本地taggit tag -d [tagname]// 第二步：推到远程git push origin :refs/tags/[tagname] vscode git密码重置vscode会帮我们记住git账号密码。当git账号变更导致vscode提示身份校验失败时，需要重置密码。 12// 清空密码git config --system --unset credential.helper 重置后，再次提交代码，会弹窗提示输入新的账号密码 参考资料http://blog.codingplayboy.com/2017/04/06/git_branch/http://blog.codingplayboy.com/2017/04/14/git_rebase/#rebase","link":"/2019/12/01/tools/git/"},{"title":"fiddler捕获https包的原理","text":"fiddler代理http协议大家都清楚原理，实际上就是正向代理。正向代理是什么呢？简单来说，就是，一方面，fiddler对浏览器客户端伪造成服务器，另一方面对真实的服务器伪造成客户端。 那么，https作为一种双向验证机制的协议，是如何让fiddler实现抓包的呢？ https其实就是比http多了个加密和解密的过程。 https的作用，其实依赖于证书的信任机制。受信任的证书机构向服务端颁发CA证书，浏览器以及系统默认保存了该机构的根证书。 fiddler其实是自己造了一个证书，如果想抓客户端的流量，就需要客户端手动信任该证书。这也是https抓包的关键。 具体步骤如下图：","link":"/2020/10/01/tools/https-through-fiddler/"},{"title":"npm学习总结","text":"dependencies如果是工具库之类的项目，发布之后，第三方使用时会安装dependencides，优先安装在第三方的目录下。 项目依赖和工具库依赖不冲突，则依赖安装到项目下，否则就会在这个工具库的目录下再安装一份。 devDependencies普通业务项目开发时，dependencies和devDependencies区别感知不大。但是如果我们开发的是一个工具库，publish之后生成的package.json中是没有devDependencies的。 peerDependencies同等依赖。这个同等的意思是，你想引用我这个库，你最好也一起安装这些依赖，要和我平级安装在你的目录下，而不是像dependencies一样有可能安装在我的库目录下面。 命令npm installnpm install的依赖安装处理逻辑如下图： 项目依赖和工具库依赖冲突项目依赖和工具库依赖不冲突，则依赖安装到项目下，否则就会在这个工具库的目录下再安装一份。 项目有如下依赖： 123456{ &quot;dependencies&quot;: { &quot;fetch&quot;: &quot;^1.1.0&quot;, &quot;biskviit&quot;: &quot;1.0.1&quot; }} fetch@^1.1.0的依赖如下： 12345{ &quot;dependencies&quot;: { &quot;biskviit&quot;: &quot;2.0.1&quot; }} 由于项目顶级依赖和fetch对biskviit的版本不一致，存在冲突，所以biskviit在项目的node_modules目录下安装一份1.0.1的版本，然后在node_modules/fetch/node_modules目录下安装2.0.1版本。 工具库之间依赖冲突假如项目的依赖如下： 123456{ &quot;dependencies&quot;: { &quot;fetch&quot;: &quot;^1.1.0&quot;, &quot;biskviit&quot;: &quot;2.0.0&quot; }} fetch@^1.1.0的依赖如下： 12345{ &quot;dependencies&quot;: { &quot;biskviit&quot;: &quot;1.0.1&quot; }} 安装fetch时，遇到了biskviit@1.0.1，会先检查项目依赖有没有biskviit。找到了，但是版本不一致，npm会选择较高的版本安装在顶级node_modules目录下，其余版本安装在各自工具库的目录下。 npm init初始化npm管理的项目，结果是一个package.json文件。 也可以通过config命令修改单个字段： 1234npm config set init.author.name &quot;Lucas&quot;npm config set init.author.email &quot;lucasXXXXXX@gmail.com&quot;npm config set init.author.url &quot;lucasXXXXX.com&quot;npm config set init.license &quot;MIT&quot; npm ls列出当前目录下npm包列表，以及之间的依赖关系。 npm config get cache获取npm包本地缓存的目录 私有npm搭建工具nexus、verdaccio 以及 cnpm npx 命令工具1npm install -g npx 假如，npm安装了webpack-cli，package.json有个script为： 123&quot;scripts&quot;: { &quot;dev&quot;: &quot;webpack&quot;} 我们可以在命令行运行npm run dev执行webpack命令，但是无法在命令行直接执行webpack。只能这样： 1./node_modules/.bin/webpack npx的作用就是帮我们找到命令的路径并执行，其实就是个语法糖。 1npx webpack nrm 镜像管理设置镜像的命令： 1npm config set registry http://registry.npm.taobao.org 我们不免会出现要切换镜像的时候，但是镜像的地址可能忘记了。这时候需要一个镜像管理工具，nrm。 1234npm install -g nrmnrm add taobao/*或者其它名字*/ http://registry.npm.taobao.orgnrm ls // 查看镜像列表，以及当前使用的镜像nrm use taobao // 切换镜像 参考资料 没想到你是这样的npm install npm 安装机制及企业级部署私服原理","link":"/2021/05/20/tools/npm-learn/"},{"title":"插件Pipeline: Groovy","text":"Jenkins 自动化构建基于一系列插件，常用的插件 最基础的是流水线插件。公司内的流水线插件配置使用Pipeline: Groovy。该插件的基本配置如下。 可以直接在文本框写入简单的脚本（Pipeline script），也可以读取Jenkinsfile内的流水线脚本（Pipeline script from scm）。scm全称是Source Control Management，如gitlab。 选择了SCM之后需要配置git的地址和账号密码： 选择构建分支： 构建分支BRANCH的值来源于参数，需要配置参数化构建，Jenkins可配置的参数类型有： 其中，Git Parameter类型需要安装插件：Git Parameter。 该插件获取以下类型的值，并赋值给我们定义的变量名BRANCH（可以是其它名字）： 分支选择时可以配置过滤器以及分支显示框的高度： 另外可以配置其它参数，如构建环境：checkbox类型的值传入Jenkinsfile中的格式为字符串，分隔符和Jenkins上的配置一致。 Jenkinsfile中可以通过params 获取到参数化构建中传入的参数： 选择构建分支时，可以使用参数化构建传入的参数： pipeline:Groovy可以配置构建执行脚本文件路径：","link":"/2021/04/30/tools/pipeline-groovy/"},{"title":"vscode 快捷键","text":"重命名函数或者变量1F2 + 点击变量名（或函数名）：会出现一个输入框可修改变量名 复制并粘贴行12shift + Alt + 下箭头：复制并粘贴到下面一行shift + Alt + 上箭头：复制并粘贴到上面一行 复制光标（多行同时修改）12ctrl + Alt + 上箭头：在上一行同一列生成一个光标ctrl + Alt + 下箭头：在下一行同一列生成一个光标 标签展开折叠12ctrl + shift + [：折叠ctrl + shift + ]：展开","link":"/2021/07/12/tools/vscode-keymap/"},{"title":"一次被折磨到头疼的经历","text":"背景我们有个多应用公共仓库，不同应用打包时需要不同的manifest.json文件。 每个应用都有一个manifest.xxx.json文件，打包时需要使用该文件替换掉manifest.json。我们使用了nodeJs的child_process.exec来执行cp命令： 1cp -f F:\\pathToJson\\manifest.xxx.json F:\\pathToJson\\manifest.json 在某个同事的windows电脑上执行时报错： 123456`Uncaught Error: Command failed: cp -f F:\\pathToJson\\manifest.xxx.json F:\\pathToJson\\manifest.jsonat ChildProcess.exithandler (child_process.js:303)at ChildProcess.emit (events.js:182)at maybeClose (internal/child_process.js:961)at Process.ChildProcess._handle.onexit (internal/child_process.js:248)` 这个报错信息只是简单的说明child_process中断，并没有详细的错误原因。 摸索试着在cmd中执行一样的命令，发现报错： 1系统找不到指定文件 为啥？？这个文件的确是存在的哇？我换了个文件，也是一样的报错。目前还不清楚是什么原因。 根据网上的经验，尝试过以下可能原因： 文件路径名太长 出现了中文路径 权限问题 试下其它的文件类型 发现以上可能性都排除。 接着在powershell中执行一样的命令，竟然成功了。作为命令行小白，去查了下二者的区别，大致结论是：powershell就是cmd的超集，不仅可以调命令，还可以连接数据库甚至编程。然而这些信息并没有给我带来灵感。 无路可走的我尝试对这句命令进行各种改参数尝试，发现删掉-f参数就成功了。 基于这一点线索，我尝试将参数改成-i，-d等都是一样的报错，我得出1个结论：cp后面的参数都是多余的！基于以前了解过命令别名，瞬间得出结论：cp命令本身包含了某个参数！换句话说，cp本身是某个命令别名！ 在C:\\windows\\system32\\目录下发现了一个cp.bat文件，里面赫然写着： 12@echo off DOSKEY cp=copy 所以啊，cp命令本身是Linux系统的，为什么之前就没质疑过呢？害得我浪费了这么长时间。 先把命令别名这个干扰项删除，然后再执行一次： 1cp -f F:\\pathToJson\\manifest.xxx.json F:\\pathToJson\\manifest.json 这次报错变为： 1cp不是内部或外部命令,也不是可运行的程序 因此，接下来的问题是，NodeJs在调用child_process.exec时，使用的命令行工具是哪个呢？ 结论 如果对命令行不熟的话就不要随便对命令行改造，否则在遥远对将来将成为一个巨坑。 当对一个问题产生怀疑时，不要轻易让它擦肩而过。","link":"/2021/07/08/think/a-hard-experience/"},{"title":"一次技术方案的分析过程","text":"分析技术方案时，保持以终为始的原则。思维就像一棵树，方案就像树枝，遍历之后发现不可行，只需要往根部回溯，重新思考达到目标的其它方法。 背景这是我负责的一个H5项目，内嵌于APP的webview，页面跳转通过打开新的webview来实现类app的效果。 在app内从另外一个项目跳转到该应用时，需要带上一个sourceid，标记引流入口。sourceid可能是来源于首页或者商品详情页，只有在下单的时候会提交给订单。 任务对该sourceid生命周期的要求是： 外部项目跳转进入该项目之后，到关闭由它打开的所有页面为止，算一个生命周期。 行动从页面跳转传参入手app为和提供了桥接sdk，应用内webview调用的是同一个api，打开新窗口前可以使用proxy拦截该api，获取当前窗口的链接，将链接上的sourceid带到新窗口上，实现sourceid参数的透传。 这个方法简单粗暴，却有明显的缺点： 业务和工具耦合，不利于维护 分享转发前需要把该参数去掉，会影响到旧的逻辑 该方法可行，但是属于对公共代码的修改，容易引发bug，暂时纳入备选方案。 从本地存储方案入手浏览器本地缓存方案有localstorage、sessionStorage、cookie。这些方案在webview中是否也适用呢？ 经过在ios中验证localstorage的缓存行为和浏览器类似，sessionStorage和cookie在webview之间不共享，因此2者被排除。 请教了ios客户端的同事，了解到，ios平台的app目前使用的是WKwebview实现，窗口之间使用的是不同的WKProcessPool，所以数据共享是个问题，localstorage之所以看起来像是共享了，实际上只是在打开同源窗口时复制了一份，新开的窗口对localStorgae所做的修改不会对旧窗口有影响。这些问题在以前UIwebview开发的时代是不存在的，而UIwebview的是因为内存占用过高而逐渐被淘汰。 可共享的存储方案就只剩下localstorage。由于localstorage属于持久化存储，想要识别一次完整使用，需要抓住一个边界点：要如何识别一次完整使用，是否具有开始或者结束的标志。在这个边界点更新sourceid 完整使用的标志有： 该webview是应用中当前存在的唯一本项目的webview，标记一次使用的开始 应用中当前存在的唯一本项目的webview被销毁，标记一次使用的结束 这2种标志如何去标记呢？我想到了以下办法： app提供相关api告诉我们是否是同源webview的第一个页面，就像微信小程序那样，打开非首页的头部左上角会显示一个home按钮。很遗憾没有找到相关api。 像window.onbeforeunload那样监听页面销毁，存储过sourceid的页面在页面销毁前销毁缓存的sourceid。通俗来讲，就是自产自销（销毁）。经测试发现，webview关闭并不会触发window.onbeforeunload和onunload事件。该方法不可行。 不那么完美的实现方案当没有完美的解决方案时，问自己，我们真的一定要完美的实现吗？经过和产品的讨论，产品方认为，不需要。可以根据用户的使用习惯，大致确定sourceid的合理有效时间，通过localstorage实现超时清理方案。 结论又一个很简单的决策公式：决策 = 收益 - 成本 - 风险以下列出了暂时可行的方案评估表： 方案 收益 成本（开发） 风险（上线+后期维护） 决策 proxy拦截api添加参数 10 3 1+1 5 localstorage有效期 8 1 0+0 7 根据上表的结果，最终选择了“localstorage有效期”这个方案。","link":"/2021/05/10/think/fanganfenxi/"},{"title":"四象限时间管理","text":"史蒂芬·科维的《高效能人士的七个习惯》在描述如何实现个人领域成功时提到了一个很重要的习惯，“要事第一”。 通常我们列出来的TODO list是线性的，从上至下排列，我们的评判标准只有一个：是否重要。 一、2个维度 4个象限2个维度： 是否重要 重要性对一个人来说要从价值观的角度去考虑。这件事做了之后是否有收获，这个收获一定要对自己有意义。 通常大家觉得，让自己有收获的事情才是最重要的。我觉得，工作期间和工作之余要区分开来。即在该做什么事情的时候就做什么事情。所以，针对工作和生活可以使用2份4象限表。 是否紧急 在近期内必须要完成的，即紧急的 一般比较紧急的是有deadline的事情。 工作上的例子：项目上线，会议前的方案搜集 生活中的例子：上学，煮饭 4个象限： 重要且紧急 重要不紧急 不重要但紧急 不重要不紧急。 二、如何区分事件属于哪个象限？以下针对4个象限的界定标准进行描述。 重要&amp;紧急 (Urgent &amp; Important)这个象限内的事情可以说不得不做。生活中应该尽量避免堆积太多此类事情，否则整日焦头烂额。 不立即做的话将来随时可能产生危机 必须在deadline之前赶出来，这个deadline强调外界压力 重要&amp;不紧急 (Important &amp; Not Urgent) 有助于个人长远发展的事情， 比如学习计划，技术方案调研 有助于群体长远发展的事情，比如培训计划 有助于减少“重要紧急”事项的事情。 我们通常说，有拖延症的人通常指，把重要但是不紧急的事情拖延到演变为重要紧急的事情，导致花更多的时间在第一象限。 紧急&amp;不重要 (Urgent &amp; Not Important) 需要近期做的事情，迫不得已可以选择不做或者接受延期的 时间比较赶，但是不怎么耗费精力 这类工作最好做，但是在精力状态一般的情况下做，必要的时候选择不做。这样可以充分利用以及节约时间。这类事情包括约会，群体活动，回复邮件。 不重要&amp;不紧急 (Not Important &amp; Not Urgent) 纯粹打发时间，没有任何实际意义 短期精神满足，实则空虚 这类事情在其它象限的事情没有处理完的时候尽量不要做。除非其它象限的事情完全没有精力做下去了又不想休息。 三、如何实施1、针对列出的任务清单，问自己2个问题： 这件事情，真的很重要吗？如果是工作任务，是否属于高优先级的任务？如果是学习任务，是否能让自己有所收获？所需要的时间是多久？ 通过以上问题，把任务分成重要和不重要的，相同类别下的任务分别赋值一个重要指数。 这件事情你自己计划或者上级需要什么时候完成？写下deadline，给自己定下的deadline最好比实际要求的更早。 通过以上问题，把最近1周内需要做的事情按照deadline进行排序，其它的事情暂时安排到下周。如果任务需要花的时间比较长，最好做一下任务分解，说不定可以分解出一些可以延后的任务。 2、针对排好的任务进行象限组合、排序把每个任务放到所属的象限内，并根据2个维度的指数进行象限内排序。 3、执行顺序大体上任务的执行顺序按照 重要&amp;紧急，重要&amp;不紧急，紧急&amp;不重要，不紧急不重要 的顺序来。 但是，如果你是替别人打工，有些工作上“不重要且紧急”的事情需要排在“重要&amp;不紧急”的事情前面，往往前者比后者更加耗时间，所以可以选择在前者的间隙处理后者。 4、每日调整&amp;总结安排总会因为各种原因变化，我们要重视对任务重新梳理的过程，以免做无用功。 不要每天给自己安排过多的任务，总结的时候发现没有按时完成任务会带来懊悔和自我否定。合理的安排比压榨自己更加划算。","link":"/2019/04/09/think/manage-time/"},{"title":"uni-app开发注意事项","text":"对Vue原生语法的支持 不支持v-model 内置组件picker 日期 无法自定义按钮颜色 样式 组件之间的样式互不影响，跨组件的样式定义不会生效，如果想穿透组件层级覆盖样式，需要在页面级别的文件中定义样式 h5编译出来的样式默认使用了scoped，如果想要跨组件层级穿透样式，需要在样式定义前加上/deep/ 引入本地的font-family时，font-face定义需要将url直接赋值为绝对路径，或者转化为base64字符串，不能直接引用相对路径，否则会出现找不到字体文件的报错 class绑定不支持模板字符串拼接1:class=&quot;`rank-${index}`&quot; 这种语法不支持，但是支持表达式拼接：1:class=&quot;'rank'+index&quot; 自定义组件 自定义组件上绑定原生事件需要用.native修饰符 1&lt;we-button @click.native=&quot;cancel&quot;&gt;取消&lt;/we-button&gt; 自定义组件绑定class和style样式不会透传到组件内部根元素上 不能直接在自定义组件上使用v-slot作为插槽，需要包裹一层template 自定义组件注册为全局组件时，本地开发需要重启。否则引用时属性传进去全是undefined 自定义组件模式下，子组件修改父组件传入的对象的属性不会更新到视图。 uni-ui版本问题 uni-popup组件，1.0.8版本时uni-popup容器没有设置z-index。1.1.9版本却设置了z-index为99，会出现样式兼容问题。因此最好固定版本。 插槽uni-app目前作用域插槽仅支持解构插槽，且作用域插槽不能使用父组件的属性 扩展运算符dcloud问题版本：&lt;= 2.0.0-28720200819001组件绑定属性时可以使用扩展运算符，但是，为自定义事件回调传参时，不能使用扩展运算符。 123456789101112131415161718192021222324252627&lt;template&gt; &lt;view class=&quot;content&quot;&gt; &lt;text class=&quot;title&quot; @click=&quot;handleClick({...myParams})&quot;&gt;点我&lt;/text&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default { data() { return { myParams: { name: 'Mac' } } }, onLoad() { }, methods: { handleClick(params) { console.log('handleClick',params) } } }&lt;/script&gt;","link":"/2021/06/07/uni-app/attentions/"},{"title":"修改uni-app的默认打包路径","text":"背景uni-app默认只有开发和生产环境，打包生成的路径默认下是如下映射关系： NODE_ENV 目录 production dist/build/${UNI_PLATFORM} 其它 dist/dev/${UNI_PLATFORM} 需求如果新增自定义环境’test’和’preproduction’，则默认都是按照’dev’环境去映射打包路径。新增的环境要怎么做？官方文档并没有明确说明。 我们希望让每个环境都有对应的打包路径： NODE_ENV 目录 production dist/build/${UNI_PLATFORM} preproduction dist/prev/${UNI_PLATFORM} test dist/test/${UNI_PLATFORM} dev dist/dev/${UNI_PLATFORM} 通过查找源码中打包相关配置，发现有个UNI_OUTPUT_DIR参数可以配置打包路径，覆盖掉默认行为。 1&quot;test&quot;: &quot;cross-env UNI_OUTPUT_DIR=dist/test/mp-weixin NODE_ENV=test UNI_PLATFORM=mp-weixin vue-cli-service uni-build&quot;","link":"/2021/06/08/uni-app/bundle-path/"},{"title":"uni-app 小程序自定义图标组件","text":"图标组件支持的功能： 图标颜色 图标名称 图标边距 图标大小 事件类型 事件名称 事件描述 click 点击事件 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!--图标组件&lt;com-icons name=&quot;icon-location&quot; size=&quot;28rpx&quot; padding=&quot;0 10rpx&quot; color=&quot;#ffffff&quot;&gt;&lt;/com-icons&gt;--&gt;&lt;template&gt; &lt;text class=&quot;uni-icons iconfont&quot; :class=&quot;name&quot; :style=&quot;{ fontSize: size, color: color, padding: padding }&quot; @click=&quot;_onClick&quot;&gt;&lt;/text&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'uni-icons', props: { name: { // 图标类型，拼接前缀icon- type: String }, size: { // 图标大小 type: String, default: 'inherit' }, color: { // 图标颜色 type: String, default: 'inherit' }, padding: { // 内边距 type: String, default: '0' } }, methods: { _onClick() { this.$emit('click') } }}&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt; @import 'path-to/iconfont.less';&lt;/style&gt;","link":"/2020/11/20/uni-app/com-icons/"},{"title":"uni-app 小程序自定义导航栏组件","text":"该组件是基于uni-ui扩展组件uni-nav-bar修改。导航组件严格来说是有2个组件组成：状态栏组件，头部组件 getStatusBarHeight和getMenuButtonBoundingClientRect方法可以获取小程序状态栏和头部胶囊信息，取值关系如下： 需要注意的是，通过getMenuButtonBoundingClientRect方法top属性一般比getStatusBarHeight的值大，且不同设备具体差异大小不同。 关于状态栏组件，具体搜索文章小程序状态栏组件。 导航组件该组件依赖于以下组件： com-icons iconfont组件 com-status-bar 状态栏组件 以上组件可通过搜索名称查找相关代码。 导航组件具有以下功能： 滚动头部固定/跟随文档 自定义返回按钮、按钮后的文案、左侧/右侧区域宽度 头部固定时是否需要保持高度（避免业务方做高度兼容） 头部透明度（支持头部随着滚动过渡） 是否需要状态栏 自定义返回按钮点击行为 小程序环境自动判断是否需要显示回到首页按钮 事件类型 事件名称 事件描述 clickLeft 点击左侧区域 clickRight 点击右侧区域 方法 方法名称 方法描述 getHeight 获取导航高度 使用时需要修改以下功能： icon组件对应的icon字体需要根据具体的应用修改 HOME_PATH对应的值根据具体的应用修改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413&lt;template&gt; &lt;view class=&quot;uni-navbar&quot;&gt; &lt;view :class=&quot;{ 'uni-navbar--fixed': fixed, 'uni-navbar--shadow': shadow, 'uni-navbar--border': border }&quot; :style=&quot;{ 'background': backgroundColor, opacity: opacity }&quot; class=&quot;uni-navbar__content&quot;&gt; &lt;com-status-bar v-if=&quot;statusBar&quot; /&gt; &lt;view :style=&quot;{ color: color,background: backgroundColor, height: headerHeight, lineHeight: headerHeight }&quot; class=&quot;uni-navbar__header uni-navbar__content_view&quot;&gt; &lt;!-- 左侧（默认点击行为：返回上一页。可重写） --&gt; &lt;view @click=&quot;onClickLeft&quot; class=&quot;uni-navbar__header-btns uni-navbar__header-btns-left uni-navbar__content_view&quot; :style=&quot;{width: leftIconWidth}&quot;&gt; &lt;!-- 回到首页按钮（分享场景）（与其它按钮或者文案互斥） --&gt; &lt;!-- #ifdef MP-WEIXIN --&gt; &lt;view class=&quot;uni-navbar__content_view&quot; :class=&quot;{'header-icon-with-bg': showIconBg}&quot; v-if=&quot;showHome&quot; @click=&quot;goHome&quot;&gt; &lt;com-icons :color=&quot;color&quot; name=&quot;icon132&quot; size=&quot;40rpx&quot; /&gt; &lt;/view&gt; &lt;!-- #endif --&gt; &lt;!-- 返回按钮 --&gt; &lt;view class=&quot;uni-navbar__content_view&quot; :class=&quot;{'header-icon-with-bg': showIconBg}&quot; v-if=&quot;!showHome &amp;&amp; leftIcon &amp;&amp; showLeftBack&quot; &gt; &lt;com-icons :color=&quot;color&quot; name=&quot;icon9&quot; size=&quot;40rpx&quot; /&gt; &lt;/view&gt; &lt;!-- 左侧显示文案 --&gt; &lt;view class=&quot;uni-navbar-btn-text uni-navbar__content_view&quot; :class=&quot;{ 'uni-navbar-btn-icon-left': leftIcon }&quot; v-if=&quot;!showHome &amp;&amp; leftText.length&quot;&gt; &lt;text :style=&quot;{ color: color, fontSize: '28rpx' }&quot;&gt;{{ leftText }}&lt;/text&gt; &lt;/view&gt; &lt;!-- 左侧区域插槽（具名插槽） --&gt; &lt;slot name=&quot;left&quot; /&gt; &lt;/view&gt; &lt;!-- 标题区域 --&gt; &lt;view class=&quot;uni-navbar__header-container uni-navbar__content_view&quot;&gt; &lt;view class=&quot;uni-navbar__header-container-inner uni-navbar__content_view&quot; v-if=&quot;title.length&quot;&gt; &lt;text class=&quot;uni-nav-bar-text&quot; :style=&quot;{color: color }&quot;&gt;{{ title }}&lt;/text&gt; &lt;/view&gt; &lt;!-- 标题插槽（无名插槽） --&gt; &lt;slot /&gt; &lt;/view&gt; &lt;!-- 右侧按钮区域 --&gt; &lt;view @tap=&quot;onClickRight&quot; class=&quot;uni-navbar__header-btns uni-navbar__header-btns-right uni-navbar__content_view&quot; :style=&quot;{width: rightIconWidth}&quot;&gt; &lt;view class=&quot;uni-navbar__content_view&quot; :class=&quot;{'header-icon-with-bg': showIconBg}&quot; v-if=&quot;rightIcon&quot;&gt; &lt;com-icons :color=&quot;color&quot; :name=&quot;rightIcon&quot; size=&quot;56rpx&quot; /&gt; &lt;/view&gt; &lt;!-- 优先显示图标 --&gt; &lt;view class=&quot;uni-navbar-btn-text uni-navbar__content_view&quot; v-if=&quot;rightText.length &amp;&amp; !rightIcon.length&quot;&gt; &lt;text class=&quot;uni-nav-bar-right-text&quot;&gt;{{ rightText }}&lt;/text&gt; &lt;/view&gt; &lt;!-- 右侧区域插槽（具名插槽） --&gt; &lt;slot name=&quot;right&quot; /&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 副标题（样式完全自定义） --&gt; &lt;view class=&quot;uni-navbar__sub-header&quot;&gt; &lt;slot name=&quot;sub-nav&quot;&gt;&lt;/slot&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 标题区域占位 --&gt; &lt;view class=&quot;uni-navbar__placeholder&quot; v-if=&quot;fixed &amp;&amp; holdPlace&quot;&gt; &lt;com-status-bar v-if=&quot;statusBar&quot; /&gt; &lt;view class=&quot;uni-navbar__placeholder-view&quot; :style=&quot;{'padding-top': subHeaderHeight, height: headerHeight}&quot;/&gt; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;// 首页路径const HOME_PATH = 'pages/index/index'var CustomNavbarHeight = uni.getCustomNavbarHeight() /** * NavBar 自定义导航栏 * @description 导航栏组件，主要用于头部导航 * @tutorial https://ext.dcloud.net.cn/plugin?id=52 * @property {String} title 标题文字 * @property {String} leftText 左侧按钮文本 * @property {String} rightText 右侧按钮文本 * @property {String} leftIcon 左侧按钮图标（图标类型参考 [Icon 图标](http://ext.dcloud.net.cn/plugin?id=28) type 属性） * @property {String} rightIcon 右侧按钮图标（图标类型参考 [Icon 图标](http://ext.dcloud.net.cn/plugin?id=28) type 属性） * @property {String} leftIconWidth （扩展属性）左侧按钮区域宽度 用来满足设计稿要求 * @property {String} rightIconWidth （扩展属性）右侧按钮区域宽度 用来满足设计稿要求 * @property {String} color 图标和文字颜色 * @property {String} backgroundColor 导航栏背景颜色 * @property {Boolean} fixed = [true|false] 是否固定顶部 * @property {Boolean} holdPlace = [true|false] （扩展属性）固定在顶部时，是否需要占位 * @property {Boolean} opacity = 0-1 （扩展属性）头部透明度 用于头部滚动渐变 * @property {Boolean} statusBar = [true|false] 是否包含状态栏 * @property {Boolean} shadow = [true|false] 导航栏下是否有阴影 * @property {Boolean} border = [true|false] 导航栏下是否有边框线 * @event {Function} showLeftBack （扩展属性）是否显示返回按钮 * @event {Function} clickLeftBack （扩展属性）点击左侧区域是否关闭当前窗口 */export default { name: &quot;NavBar&quot;, props: { title: { type: String, default: &quot;&quot; }, leftText: { type: String, default: &quot;&quot; }, rightText: { type: String, default: &quot;&quot; }, leftIcon: { type: String, default: &quot;&quot; }, leftIconWidth: { type: String, default: &quot;132rpx&quot; }, rightIcon: { type: String, default: &quot;&quot; }, rightIconWidth: { type: String, default: '132rpx' }, fixed: { type: [Boolean, String], default: false }, holdPlace: { type: Boolean, default: true }, color: { type: String, default: &quot;#000000&quot; }, opacity: { type: [String,Number], default: &quot;1&quot; }, backgroundColor: { type: String, default: &quot;#FFFFFF&quot; }, statusBar: { type: [Boolean, String], default: false }, shadow: { type: [String, Boolean], default: false }, border: { type: [String, Boolean], default: true }, clickLeftBack: { // 点击返回按钮区域是否返回上一页/路由 type: [String, Boolean], default: true }, showLeftBack: { type: [Boolean, String], default: true } }, data() { return { showIconBg: false, // 是否显示按钮的背景色 showHome: false, // 是否显示回到首页按钮 showNavBar: true, headerHeight: CustomNavbarHeight + 'px', // 头部高度，默认是40 subHeaderHeight: '' // 子头部高度 } }, watch: { color() { this.handleColorChange() } }, created() { this.handleColorChange() }, mounted() { if(uni.report &amp;&amp; this.title !== '') { uni.report('title', this.title) } this.updateHeight() // #ifdef MP-WEIXIN this.judgeHome() // #endif }, updated() { this.updateHeight() }, methods: { updateHeight() { this.getSubHeaderHeight() this.getHeight() }, handleColorChange() { let color = this.color &amp;&amp; this.color.toLocaleLowerCase() // 只有背景色透明才设置按钮的背景颜色 let bgTransparent = this.backgroundColor == 'transparent' || this.backgroundColor == 'inherit' // 设置状态栏字体颜色 if (color &amp;&amp; (color === '#ffffff' || color === '#fff')) { uni.setNavigationBarColor({ frontColor: '#ffffff', backgroundColor: 'transparent' }) if (bgTransparent) this.showIconBg = true } else { uni.setNavigationBarColor({ frontColor: '#000000', backgroundColor: 'transparent' }) this.showIconBg = false } }, /** * 获取节点offset值 （而非小程序提供的相对可视窗口的offset值） * @param {string} selector 节点 与 select()方法一致 * @param {string} parent 节点相对滚动节点，非必传，不传以 viewport为默认值 * @param {string} context 查询上下文（页面/组件实例），含有自定义组件的页面，或者自定义组件中调用，必传 */ getOffset(selector, parent, context) { let query = context ? context.createSelectorQuery() : uni.createSelectorQuery(); let parentQuery = parent ? query.select(parent) : query.selectViewport() query.select(selector).boundingClientRect() parentQuery.scrollOffset() return new Promise((resolve, reject) =&gt; { query.exec(([selectRect, parentRect]) =&gt; { if (selectRect) { resolve({ top: selectRect.top + parentRect.scrollTop, left: selectRect.left + parentRect.scrollLeft, height: selectRect.height, width: selectRect.width, bottom: selectRect.bottom }) } else { console.warn(`[mp::getOffset]: 获取目标元素${selector}的offset信息失败`) resolve({ top: 0, left: 0, height: 0, width: 0 }) } }) }) }, async getSubHeaderHeight() { let subHeaderOffset = await this.getOffset('.uni-navbar__sub-header', null, this) this.subHeaderHeight = subHeaderOffset.height + 'px' }, async getHeight() { let navOffset = await this.getOffset('.uni-navbar__content', null, this) return navOffset }, // #ifdef MP-WEIXIN /** * 判断是否需要显示home按钮（只有小程序需要） **/ judgeHome() { // 页面栈栈顶，且路径为非首页，则显示home按钮 let pages = getCurrentPages() if ((pages.length &lt;= 1) &amp;&amp; HOME_PATH !== pages[0].route) { this.showHome = true } }, goHome() { uni.reLaunch({ url: '/'+HOME_PATH, }) }, // #endif onClickLeft() { if (this.clickLeftBack) { uni.navigateBack() } else { this.$emit(&quot;clickLeft&quot;); } }, onClickRight() { this.$emit(&quot;clickRight&quot;); } }};&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt; $nav-height: 44px; .uni-nav-bar-text { font-size: $uni-font-size-lg; } .uni-nav-bar-right-text { font-size: $uni-font-size-base; } .uni-navbar { position: relative; width: 100%; font-family: PingFangSC-Medium, PingFang SC; box-sizing: border-box; } .uni-navbar__content { position: relative; width: 100%; background-color: $uni-bg-color; } .uni-navbar__content_view { display: flex; align-items: center; flex-direction: row; } .uni-navbar__header { display: flex; flex-direction: row; width: 100%; height: $nav-height; line-height: $nav-height; font-size: 32rpx; } .header-icon-with-bg { display: flex; justify-content: center; align-items: center; align-content: center; background: rgba($color: #000000, $alpha: 0.2); border-radius: 100%; height: 52rpx; width: 52rpx; } .uni-navbar__header-btns { display: flex; flex-wrap: nowrap; padding: 0 12px; justify-content: center; align-items: center; box-sizing: border-box; } .uni-navbar__header-btns-left { display: flex; box-sizing: border-box; justify-content: flex-start; } .uni-navbar__header-btns-right { display: flex; box-sizing: border-box; justify-content: flex-end; margin-right: 10rpx; } .uni-navbar__header-container { flex: 1; font-weight: 600; } .uni-navbar__header-container-inner { display: flex; flex: 1; align-items: center; justify-content: center; font-size: $uni-font-size-base; } .uni-navbar__placeholder-view { height: $nav-height; box-sizing: content-box; } .uni-navbar--fixed { position: fixed; z-index: 998; } .uni-navbar--shadow { box-shadow: 0 1px 6px #ccc; } .uni-navbar--border { border-bottom-width: 1rpx; border-bottom-style: solid; border-bottom-color: $uni-border-color; }&lt;/style&gt;","link":"/2020/11/20/uni-app/com-nav-bar/"},{"title":"uni-app 小程序状态栏组件","text":"小程序状态栏高度通过wx.getSystemInfoSync().statusBarHeight获取是最准确的。单位是px。wx.getMenuButtonBoundingClientRect()方法获取的top属性时不准确的，不能作为参考。 12345678910111213141516171819202122232425&lt;template&gt; &lt;view :style=&quot;{ height: statusBarHeight }&quot; class=&quot;uni-status-bar&quot;&gt; &lt;slot /&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;const statusBarHeight = uni.getStatusBarHeight()export default { name: 'status-bar', data() { return { statusBarHeight: statusBarHeight + 'px' } }}&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt; .uni-status-bar { width: 750rpx; height: 20px; }&lt;/style&gt;","link":"/2020/11/20/uni-app/com-status-bar/"},{"title":"uni-app 自定义条件编译","text":"package.json文件中添加如下配置： 123456789101112131415161718192021222324&quot;uni-app&quot;: { &quot;scripts&quot;: { &quot;mp-qly&quot;: { &quot;title&quot;: &quot;趣旅游小程序&quot;, &quot;BROWSER&quot;: &quot;&quot;, &quot;env&quot;: { &quot;UNI_PLATFORM&quot;: &quot;mp-weixin&quot; }, &quot;define&quot;: { &quot;QLY&quot;: true } }, &quot;h5-qly&quot;: { &quot;title&quot;: &quot;趣旅游h5&quot;, &quot;BROWSER&quot;: &quot;&quot;, &quot;env&quot;: { &quot;UNI_PLATFORM&quot;: &quot;h5&quot; }, &quot;define&quot;: { &quot;QLY&quot;: true } } }} 在npm script中带上custom参数： 12&quot;dev:wx:qly&quot;: &quot;uniapp-cli custom mp-qly&quot;,&quot;dev:h5:qly&quot;: &quot;uniapp-cli custom h5-qly&quot; 那么，这俩命令执行后 12// #ifdef QLY// #endif 这个条件编译是都会命中的。自定义条件编译适合在saas应用中针对业务做区分，同一个业务不同的平台保持一致性。 自定义条件编译有个缺点，就是不支持or判断 123// #ifdef BOOKING || QLYdosomething();// #endif 以上条件编译只会命中BOOKING。不会命中QLY。 解决办法 按照官方的办法处理。 分开处理123456// #ifdef BOOKINGdosomething();// #endif// #ifdef QLYdosomething();// #endif 如果是ifndef呢？既不是，也不是。 123// #ifndef BOOKING || QLYdosomething();// #endif 以上写法是不对的。可以通过嵌套解决： 12345// #ifndef BOOKING// #ifndef QLYdosomething();// #endif// #endif","link":"/2021/04/07/uni-app/custom-if/"},{"title":"uni-app的环境变量","text":"uni-app有较多环境变量，有些变量是没有体现在官方文档中的。以下是个人用过的环境变量。 NODE_ENV构建环境。该值可以影响到一些默认配置。如 值为production时： h5模式下，publicPath才能生效。 错误信息不会输出 启用terser代码压缩 值为development时： h5模式下，默认开启sourceMap UNI_PLATFORM基准平台，即代码编译目标。可选值有： h5 mp-weixin app-plus quickapp-native mp-baidu mp-toutiao mp-qq它的值决定了编译的核心流程。 UNI_INPUT_DIR入口文件所在目录，默认是src。 不只是入口文件，也代表着和入口文件层级关系固定的资源路径。 因此不管入口目录是什么，该目录下的资源要符合uni-app的规则。 UNI_OUTPUT_DIR打包后代码的输出目录。默认为： 1/dist/${process.env.NODE_ENV === 'production' ? 'build' : 'dev'}/${process.env.UNI_PLATFORM} UNI_MINIMIZE是否开启代码压缩。","link":"/2021/08/01/uni-app/env/"},{"title":"前端错误捕获学习与实践","text":"小程序和上线后遇到部分页面出现白屏的情况，小程序还好说，有些错误是可以在微信后台浏览的，H5就不一样了，经历了找遍测试机都无法复现的痛苦之后，迎来的便是缠着用户配合调试的无奈。自己动手，解决一部分开发者的痛苦。先把能捕获的错误上报先。 H5window.onerror = function (event) {}该回调可以捕获js运行时错误。如果函数返回true，就会阻止默认事件处理函数（如consoe输出）。 window.addEventListener(‘error’)123window.addEventListener('error', function (msg, url, lineNo, columnNo, error) { // 获取出错的脚本路径，行列信息，以及报错信息}, true) 该回调可以捕获js语法错误，或者运行时错误，或者脚本加载错误。比window.onerror先触发。无法阻止默认事件处理函数。 如果要和window.onerror一起使用，需要过滤要重叠的部分，该方法可以只负责监听脚本加载错误： 123456789window.addEventListener('error', event =&gt; (){ // 过滤js error let target = event.target || event.srcElement; let isElementTarget = target instanceof HTMLScriptElement || target instanceof HTMLLinkElement || target instanceof HTMLImageElement; if (!isElementTarget) return false; // 上报资源地址 let url = target.src || target.href; console.log(url);}, true); window.addEventListener(‘unhandledrejection’)123window.addEventListener('unhandledrejection', function (event) { const error = event.reason}, true) 该回调可以捕获promise链中未被catch的错误。可以通过event.preventDefault阻止默认事件处理函数（如：console输出）。 跨域资源脚本错误捕获script标签不受浏览器同源策略影响。但是，H5默认跨域js无法获取脚本错误的具体信息。除非script标签增加跨域限制，且资源返回Access-Control-Allow-Origin头部信息。 由于我们的项目，生产的静态JS资源可能使用了cdn，这种情况下，脚本报错是无法获取完整信息的。只能得到“script error.”信息。 解决办法： 为cdn资源的返回头添加Access-Control-Allow-Origin头部即可。（目前采用该方法） script标签添加： crossorigin=”anonymous”。该步骤是匿名获取目标脚本。 以上2步都要做。针对webpack的htmlWebpackPlugin，生成的动态script标签默认是没有crossorigin属性，我们可以借用以下插件帮忙完成添加属性的工作： webpack-subresource-integrity html-webpack-inject-attributes-plugin 参考资料： https://www.cnblogs.com/vivotech/p/11162672.html 现有成熟的可解决方案 trackjs sentry 小程序App.onError或wx.onError官方表示，二者的触发时机一致，但是经过实际试验，发现后者在自定义组件的生命周期钩子中并没有触发。 相关社区文章：https://developers.weixin.qq.com/community/develop/doc/000c8cf5794770272709f38a756000 官方后台官方后台可查看客户端捕获的代码报错，无需业务端重新上报。 成熟方案sentrysentry提供小程序平台方案：https://github.com/lizhiyao/sentry-miniapp 参考资料 前端异常埋点系统初探","link":"/2021/06/04/uni-app/error-catch/"},{"title":"uni-app 打包为h5时rpx编译错误","text":"某天，产品给我看了一个线上h5页面的布局问题：有个组件的padding属性不见了。我以为这是一贯的粗心导致简单的样式问题，当我打开生产页面样式审查的时候，我傻眼了： 123.comp-card .content--wrap[data-v-8ec74a42] { padding: %?22?% %?24?%; } 暂时的解决方案这个问题之前同事也遇到过，当时经过简单的实验，发现是uni-app较新版本才会出现。我们目前使用的uni-app版本都是latest，即使用较新的稳定版本。 既然没有定位到直接原因，干脆先固定到较低的版本号暂时解决问题。 分析问题特点此时，编译结果错误，uni-app版本号错误这俩关键词已经在我脑海里扎根。 为了进一步研究问题特点和原因，我尝试在开发环境复现这个问题，结果发现只有在NODE_ENV的值为production时才能出现。 继续审查了其它元素，只发现了这一处样式异常。单独的异常很难分析出问题的原因在哪里。 分析到这里没有进展，直接去uni-app的Github和社区看看有没有相关issue，还真找到了几个： https://github.com/dcloudio/uni-app/issues/1132 https://github.com/dcloudio/uni-app/issues/1069 这几个issue的最终解决办法就是使用@vue/cli 3.x的版本（我用的就是3.x啊喂！更何况uni-app现在已经支持@vue/cli 4.x了） 没有找到复现条件和demo，直接拿着这2个现象去提issue。果然等来的是类似“按照你说的条件，没发现这个问题啊”这样的回复。 刨根究底自己动手，丰衣足食。我们知道，webpack对css的处理方式通常是使用style-loader将css插入header标签中，uni-app也是如此：上图中6215就是一个css模块：这个css模块其实就是一个字符串，截取这段字符串格式化后的一部分：可以得出结论： uni-app编译后的css中，rpx单位并没有直接转化成px，因为需要根据具体的设备类型做移动端适配。这个适配工作就在style标签插入html之前。 接下来，找到rpx转px的工具函数，在@dcloudio/vue-cli-plugin-uni/packages/h5-vue-style-loader/lib/addStylesClient.js文件中，名为processCss的方法： 123456789101112131415161718192021222324252627282930313233var UPX_RE = /%\\?([+-]?\\d+(\\.\\d+)?)\\?%/gvar BODY_RE = /\\.\\?%PAGE\\?%/gvar BODY_SCOPED_RE = /\\?%PAGE\\?%\\[data-v-[a-z0-9]{8}\\]/gvar PAGE_SCOPED_RE = /uni-page-body\\[data-v-[a-z0-9]{8}\\]/gvar VAR_STATUS_BAR_HEIGHT = /var\\(--status-bar-height\\)/givar VAR_WINDOW_TOP = /var\\(--window-top\\)/givar VAR_WINDOW_BOTTOM = /var\\(--window-bottom\\)/givar VAR_WINDOW_LEFT = /var\\(--window-left\\)/givar VAR_WINDOW_RIGHT = /var\\(--window-right\\)/gifunction processCss(css) { var page = getPage() if (typeof uni !== 'undefined' &amp;&amp; !uni.canIUse('css.var')) { //不支持 css 变量 var offset = getWindowOffset() css = css.replace(VAR_STATUS_BAR_HEIGHT, '0px') .replace(VAR_WINDOW_TOP, offset.top + 'px') .replace(VAR_WINDOW_BOTTOM, offset.bottom + 'px') .replace(VAR_WINDOW_LEFT, '0px') .replace(VAR_WINDOW_RIGHT, '0px') } return css .replace(BODY_SCOPED_RE, page) .replace(BODY_RE, '') .replace(PAGE_SCOPED_RE, 'body.' + page + ' uni-page-body') .replace(/\\{[\\s\\S]+?\\}|@media.+\\{/g, function (css) { if(typeof uni === 'undefined'){ return css } return css.replace(UPX_RE, function (a, b) { return uni.upx2px(b) + 'px' }) })} 正则变量UPX_RE是生成px的关键点，replace链式调用的结尾需要对满足正则/\\{[\\s\\S]+?\\}|@media.+\\{/g的部分做px单位转换。现在可以确认的是，这个正则没有完全覆盖我们的css模块中所有的样式。 解决啦拿以下样式做一个验证： 1234567891011121314.class-a[data-v-8ec74a42] { width: %?678?%;}@media only screen and (-webkit-min-device-pixel-ratio: 2) { .class-a[data-v-8ec74a42] { -webkit-transform: scaleY(0.5); -ms-transform: scaleY(0.5); transform: scaleY(0.5); }}.class-b[data-v-8ec74a42] { font-size: %?28?%; line-height: %?88?%;} 发现@media.+\\{部分会匹配从@media到.class-b[data-v-8ec74a42] {，剩下的部分因为无法匹配\\{[\\s\\S]+?\\}就被忽略了。 根据该文件的修改记录，看到了上一次修改的commit message：哦，人家大概是想处理这样的情况下吧： 1@media screen and (max-width: 300rpx) 修正后的正则： 1/\\{[\\s\\S]+?\\}|@media[^{]+/g 既然如此，那就赶紧提个pull request叭！ 相关issue:https://github.com/dcloudio/uni-app/issues/1132https://github.com/dcloudio/uni-app/issues/1606https://github.com/dcloudio/uni-app/issues/1069https://github.com/dcloudio/uni-app/issues/2600","link":"/2021/06/29/uni-app/fix-bug/"},{"title":"uni-app H5模式下treeShaking的坑","text":"uni-apph5打包模式，使用treeShaking时，该配置只在生产模式下有效，即使部署到测试和预生产都没有问题，发布到生产之前一定要先本地打包生产模式确保无异常。 我们的项目发布到生产之后运行h5出现以下报错： 经过一番全局搜索，看到了一个插件（目录：@dcloudio/vue-cli-plugin-uni-optimize/packages/babel-plugin-uni-api/index.js）： 1234567891011121314151617181920process.UNI_APIS = new Set()module.exports = function ({ types: t}) { return { visitor: { MemberExpression (path, state) { if ( t.isIdentifier(path.node.object) &amp;&amp; ( path.node.object.name === 'uni' || path.node.object.name === 'wx' ) ) { process.UNI_APIS.add(path.node.property.name || path.node.property.value) } } } }} 该插件在获取了AST语法树之后，将遇到uni.xxx语法的对象属性引用对应的api名称添加到process.UNI_APIS中。 然而，通过调试发现代码并没有运行到此处，此路不通。 后来终于发现了一个关键线索。 读取optimization.treeShaking开关并标记 @dcloudio/vue-cli-plugin-uni/lib/env.js文件中读取到optimization.treeShaking配置为true时，就会执行以下代码： 1process.env.UNI_OPT_TREESHAKINGNG = true vue-cli-optimize插件 vue-cli-plugin-uni-optimize插件（@dcloudio/vue-cli-plugin-uni-optimize/index.js）针对uni-api做了以下事情： 将process.UNI_APIS写入@dcloudio\\vue-cli-plugin-uni-optimize.tmp\\api.js路径下的文件 将uni api的模块引用路径替换成@dcloudio\\vue-cli-plugin-uni-optimize.tmp\\api.js路径下的文件 但是我们从前文可知，唯一一处更新process.UNI_APIS的代码并未执行（猜测是uni-app代码的bug），导致uni-api update了个寂寞: 以上关键代码并未更新任何api，只是引入了一些默认的核心api（@dcloudio/vue-cli-plugin-uni-optimize/packages/webpack-optimize-plugin/api.js）: 以上代码标记部分，manifest[name][2]的值为true，即为核心api时才会被默认引入。 由于不知道什么原因没有使用babel-plugin-uni-api，而且，考虑到该插件的tree-shaking比较粗暴，增加了业务代码的开发复杂度。 而我负责的项目，业务中存在对uni的直接使用扩展运算符来实现uni-api和其它自定义api的整合： 1234sdk = { ...uni, someCustomApi: function(){...}} 即使babel-plugin-uni-api插件正常工作，根据该插件的shaking原理，我们需要将扩展运算符改为按需赋值的结构： 12345sdk = { api1: uni.api1, api2: uni.api2, someCustomApi: function(){...}} 每增加一个新的uni-api都要去修改sdk文件，这是开发不希望发生的事情。因此考虑简单粗暴从manifest.json文件入手，让每一个api都成为核心api。在compiler的beforeCompile钩子回调中修改manifest文件的标记： 12345678910111213const manifest = require('@dcloudio/uni-h5/manifest.json')Object.keys(manifest).forEach(name =&gt; { if (manifest[name].length &lt; 3) { manifest[name].push(true) }})const newManifest = JSON.stringify(manifest, null, 2);try { fs.writeFileSync(path.resolve(process.cwd(), 'node_modules', '@dcloudio/uni-h5/manifest.json'), newManifest) console.log('@dcloudio/uni-h5/manifest.json 替换成功...')} catch (err) { console.log('@dcloudio/uni-h5/manifest.json 替换失败...')} writeFileSync将json写回文件时，需要转化为字符串，为了让字符串能够换行，保持json格式，需要传入JSON.stringify的第三个参数值为2，表示保留换行和空格，以及每次缩进使用2个空格。 结果将“未开启tree-shaking”，“开启tree-shaking打包异常”，“开启tree-shaking并修复api打包异常”3个版本打包结果对比： 可以看到，uni-app的tree-shaking效果一般，修复tree-shaking的打包结果依旧比开启前少了0.1M。 uni-app 2.2 大幅优化H5端性能体验，只开发H5，也要用uni-app这篇文章提到，manifest内部的的tree-shaking其实主要做了2件事，内置组件的treeShaking和api的treeShaking，而且，文中数据显示，shaking效果拔群。但是本人尝试的结果发现效果实在一般。","link":"/2021/05/10/uni-app/h5-tree-shaking/"},{"title":"uni-app实现文本长按复制","text":"文本长按复制的实现原理小程序所有的标签css都具有user-select:none属性。可通过user-select:text使其支持长按复制。 真机调试的时候样式审查，看到的text标签具有user-select:text： 虽然审查出来样式是有user-select:text，实际上在ios设备上依旧无法长按选择。这个样式审查估计是假的吧。 开启了user-select:text的text标签，由inline布局变为inline-block，需要开发者自己做样式适配（官方说明） 安卓 css中的user-select:text有效 text标签的user-select有效 IOS css中的user-select:text无效 text标签的user-select有效 因此还是要用text标签的user-text属性。 富文本的长按复制富文本要用到rich-text标签。但是该标签不支持user-select属性。 唯一的办法就是将富文本中的文本标签都改成text标签。 插件市场有很多富文本解析插件。 mp-html文档 优点： 支持图片预览 文案长按复制 全端支持 缺陷： selectable:true 对ios无效，selectable:force才对ios有效。 selectable:force对h5无效，所以h5需要额外用user-select:text样式对容器处理。 lazy-load在小程序端有问题。图片并没有渲染出来。 H5模式下的长按复制以上都是小程序环境的处理方法。 H5 模式下，text标签的user-select属性无效，需要在css中设置user-select:text属性","link":"/2021/07/20/uni-app/longpress-copy/"},{"title":"uni-app rpx单位在h5环境转换为px的方法","text":"源码中的rpx单位，如22rpx编译后为%?22?%的格式。具体px值为多少，是根据运行时设备环境判断的。 运行时单位转换核心方法如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// newDeviceWidth通常不传，用默认值deviceWidthfunction upx2px (number, newDeviceWidth) { if (deviceWidth === 0) { checkDeviceWidth() } number = Number(number) if (number === 0) { return 0 } // 计算基准以globalStyle配置为准 const config = __uniConfig.globalStyle || __uniConfig.window || {} const maxWidth = checkValue(config.rpxCalcMaxDeviceWidth, 960) const baseWidth = checkValue(config.rpxCalcBaseDeviceWidth, 375) // 容器像素宽度值（通常和设计稿宽度一致） const includeWidth = checkValue(config.rpxCalcIncludeWidth, 750) // deviceWidth为窗口像素宽度（css层面的像素，如iphone 6: 375px） let width = newDeviceWidth || deviceWidth width = number === includeWidth || width &lt;= maxWidth ? width : baseWidth // BASE_DEVICE_WIDTH固定为750，因此代码中的值也要以750的设计稿为准 let result = (number / BASE_DEVICE_WIDTH) * width if (result &lt; 0) { result = -result } result = Math.floor(result + EPS) if (result === 0) { // 计算结果小于1px时特殊处理。 if (deviceDPR === 1 || !isIOS) { // DPR不大于1，或者不是ios设备，则一律为1px result = 1 } else { // DPR大于1，或者ios设备，则一律为0.5px result = 0.5 } } return number &lt; 0 ? -result : result}function checkDeviceWidth () { const { platform, pixelRatio, windowWidth } = uni.getSystemInfoSync() deviceWidth = windowWidth deviceDPR = pixelRatio isIOS = platform === 'ios'} 该方法在将style插入DOM之前执行。","link":"/2021/06/29/uni-app/rpx/"},{"title":"uni-app 分包优化","text":"manifest.json文件配置，可以开启分包优化。 1234567&quot;mp-weixin&quot;:{ // ... &quot;optimization&quot;: { &quot;subPackages&quot;: true } // ...} 该配置优化的具体具体逻辑： 静态文件：分包下支持 static 等静态资源拷贝，即分包目录内放置的静态资源不会被打包到主包中，也不可在主包中使用 js文件：当某个 js 仅被一个分包引用时，该 js 会被打包到该分包内，否则仍打到主包（即被主包引用，或被超过 1 个分包引用） 自定义组件：若某个自定义组件仅被一个分包引用时，且未放入到分包内，编译时会输出提示信息 划重点： 自定义组件不会自动被优化，只是会在命令行显示提示信息，并不会自动移动组件 只会自动移动可移入分包的js文件。 分析分包建议结果，发现其建议存在部分误导，开发者需要主动鉴别： 分析分包建议结果，发现其建议存在遗漏。 npm中的组件也会参与分包优化建议，但是使用easycom的情况下是不会被提示的。","link":"/2021/06/29/uni-app/subPackages/"},{"title":"uni-app无法使用thread-loader","text":"拦截config.module.rules，给每个rule插入thread-loader。按照文档的说法，thread-loader有使用限制： 翻译一下，有以下限制： 无法在具有输出文件功能的loader上使用 不能在plugin生成的loader上使） 不能在访问了webpack配置的loader上使用 暂时先不理会这些限制，先让它跑起来。 安装最新版（3.0.3），vue.config.js文件添加以下代码： 1config.module.rules[19].use.unshift({loader: 'thread-loader'}) 实验需要，随便找了一个/.vue$/文件添加thread-loader，运行一下有报错： 去github上查到类似的issue ：https://github.com/dcloudio/uni-app/issues/2198根据别人的解决方案，尝试了升级版本，更换npm源，都没有解决。 无奈只能自己定位错误。代码定位到vue-li-shared/lib/platform文件： 1const uniPluginOptions = global.uniPlugin.options || {} global.uniPlugin值为undefined，我找下uniPlugin的来源，发现全局只赋值了一次，而thread-loader之间的global变量是不共享的。 后来跑去看了源码，看到在设置默认vue.config.js配置时的一段注释： 看来果真如此，自定义compiler不是在每个线程都执行一遍的，可能只有第一个线程能拿到这个自定义的compiler。 不能用thread-loader的另外一个原因是，uni-app的loader使用了不能序列化的配置，否则会出现loadder内部报错属性undefined之类的bug，正如vue-cli官网解释的那样：","link":"/2021/06/27/uni-app/thread-loader/"},{"title":"defineProperty","text":"定义了如下一个对象： 123456789101112let arr = { a: []}Object.defineProperty(arr, 'a', { get() { console.log('get') return [] }, set(val) { console.log('set') }}) 当执行arr.a = [1, 2]时输出 1set 当执行arr.a.push(1)或者arr.a[0] = 1时输出 1get 这说明，Array的元素的增减不会触发setter。 那，为什么在 Vue中，arr.a[0] = 1不会触发视图更新，但是arr.a.push(1)却可以呢。 Vue 将被侦听的数组的变异方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括： push, pop, shift, unshift, splice, sort, reverse 截取核心的代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/* observer/array.js */import { def } from '../util/index'const arrayProto = Array.prototypeexport const arrayMethods = Object.create(arrayProto)[ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) { // cache original method const original = arrayProto[method] def(arrayMethods, method, function mutator (...args) { // 执行默认行为 original: Array.prototype[method] const result = original.apply(this, args) // ob: Observer实例 const ob = this.__ob__ // 获取数组中新增的元素，并为其添加watcher let inserted switch (method) { case 'push': case 'unshift': inserted = args break case 'splice': inserted = args.slice(2) break } if (inserted) ob.observeArray(inserted) // notify change ob.dep.notify() return result })})// ------------------------------------- ///* util/lang.js *//** * Define a property. */export function def (obj: Object, key: string, val: any, enumerable?: boolean) { Object.defineProperty(obj, key, { value: val, enumerable: !!enumerable, writable: true, configurable: true })}// ------------------------------------- ///* observer/index.js */import { arrayMethods } from './array'function protoAugment (target, src: Object, keys: any) { target.__proto__ = src}function copyAugment (target: Object, src: Object, keys: Array&lt;string&gt;) { for (let i = 0, l = keys.length; i &lt; l; i++) { const key = keys[i] def(target, key, src[key]) }}// ...export class Observer { value: any; dep: Dep; vmCount: number; // number of vms that has this object as root $data constructor (value: any) { this.value = value this.dep = new Dep() this.vmCount = 0 def(value, '__ob__', this) if (Array.isArray(value)) { const augment = hasProto ? protoAugment : copyAugment augment(value, arrayMethods, arrayKeys) this.observeArray(value) } else { this.walk(value) } } // ... /** * Observe a list of Array items. */ observeArray (items: Array&lt;any&gt;) { for (let i = 0, l = items.length; i &lt; l; i++) { observe(items[i]) } }} 输出挂载在Vue实例上的数组和未挂载在Vue实例上的数组进行比较： 1234567891011121314151617181920&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;new Vue({ data: { arr: [1, 2] }, created() { console.log('arr on vue:', this.arr) console.log('arr free:', [1, 2]) }})&lt;/script&gt;&lt;/html&gt; 输出对比： 可以看出来，挂载在vue实例上的数组，原型是arrayMethods，arrayMethods继承于Array。 上面输出的结果说明了什么？只有调用了数组上的’push’,’pop’,’shift’,’unshift’,’splice’,’sort’,’reverse’方法，才能触发watcher更新DOM。 可运行下面的代码以做验证： 12345678910111213141516171819202122232425262728293031&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div v-for=&quot;number in arr&quot;&gt; {{number}} &lt;/div&gt; &lt;button @click=&quot;push&quot;&gt;push&lt;/button&gt; &lt;button @click=&quot;rawPush&quot;&gt;rawPush&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt;new Vue({ el: '#app', data: { arr: [1, 2] }, methods: { push() { this.arr.push('3') }, rawPush() { Array.prototype.push.apply(this.arr, [4]) } }})&lt;/script&gt;&lt;/html&gt; 上面的代码中，push方法执行后视图立即更新。rawPush方法执行后视图没有更新，但是内容有push成功。下次执行push方法才会把rawPush进去的值渲染出来。 为什么有时候直接对数组的某个元素赋值却发现有更新呢？ 原因是存在搭便车的情况。请看如下代码： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;changeArr&quot;&gt;修改arr&lt;/button&gt; &lt;button @click=&quot;changeProp&quot;&gt;修改prop&lt;/button&gt; &lt;button @click=&quot;changeBoth&quot;&gt;一起修改&lt;/button&gt; &lt;div&gt;arr:&lt;/div&gt; &lt;div v-for=&quot;(item, $index) in arr&quot; :key=&quot;$index&quot;&gt;{{item}}&lt;/div&gt; &lt;div&gt;&lt;br&gt;prop:&lt;/div&gt; &lt;div&gt;{{JSON.stringify(prop)}}&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { data() { return { arr: [1, 2], prop: { a: { b: { c: '' } } } } }, methods: { changeProp() { this.prop.a.b.c = 'hello' }, changeArr() { this.arr[0] = 111 }, changeBoth() { this.changeProp() this.changeArr() } }}&lt;/script&gt; 对数组的某个元素直接修改，视图不会先更新，除非在修改之后其它因素触发了视图更新。 假如，prop属性没有渲染在视图中，那么，点击任何一个按钮都不会刷新视图。","link":"/2019/11/03/vue/define-property/"},{"title":"手写defineReactive","text":"defineReactive是Vue响应式的核心。我们手写一个简单的defineReactive： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546let obj = { c: 2}/*** 将获取到的变量值渲染到视图**/function showGet(key, val) { console.log(key, 'get newVal', val) let bodyEle = window.document.body bodyEle &amp;&amp; (bodyEle.innerText = bodyEle.innerText + '\\n' + key + ' get newVal' + val)}/*** 将更新后的变量值渲染到视图**/function showSet(key, newVal) { console.log(key, 'set newVal', newVal) let bodyEle = window.document.body bodyEle &amp;&amp; (bodyEle.innerText = bodyEle.innerText + '\\n' + key + ' set newVal' + newVal)}function defineReactive(obj, key) { let val = obj[key] Object.defineProperty(obj, key, { enumerable: true, configurable: true, get: function() { showGet(key, val) return val }, set: function (newVal) { val = newVal showSet(key, newVal) } })}let keys = Object.keys(obj)for (const key of keys) { defineReactive(obj, key)}obj.c = 3console.log(obj.c)","link":"/2019/11/03/vue/define-reactive/"},{"title":"vue定义非响应式属性的方法","text":"created钩子函数中定义 1234created() { // 注意data中不要声明该变量名 this.testData = 'testData'} 不能在mounted钩子中定义，否则，会在首次渲染template的时候报错 自定义options 12345678910111213141516&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;p v-for=&quot;item in $options.list&quot; :key=&quot;item.value&quot;&gt;{{ item.value }}&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { name: &quot;app&quot;, data: () =&gt; { return { } }, list: []}&lt;/script&gt; Object.freeze123456789101112131415161718192021222324252627282930313233343536&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;div v-for=&quot;(item, index) in list&quot; :key=&quot;index&quot;&gt; {{ item.a }} &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { name: &quot;app&quot;, data() { return { list: Object.freeze([ { a: 1 }, { a: 1 }, { a: 1 }, { a: 1 } ]) } }, mounted() { this.list = [ { a: 2 }, { a: 2 }, { a: 2 }, { a: 2 } ].map(item =&gt; { return Object.freeze(item) }) this.list[0].a = 111 // 此行代码不会生效 console.log(this) console.log(this.list) }}&lt;/script&gt; 在mounted钩子中，组件实例上list具有getter和setter属性，说明list属性值是响应式的，就是说，直接修改List的值是可以的。 输出的list指向的数组内不具有getter和setter属性，说明list值中的元素是非响应式的。 通过这种特性，可以让list整块修改触发视图响应，但修改/删除/新增数组内的某个元素DOM都是不会响应的。Object.freeze是浅冻结， 12console.log(Object.isExtensible(this.list)) // 输出falseconsole.log(Object.isExtensible(this.list[0])) // 输出true 如果要更高提升性能，关键还是要实现深冻结: 123456list: [ { value: 1 }, { value: 2 }].map(item =&gt; { return Object.freeze(item)}) 注意： data属性加上_或者$前缀，该属性依旧是响应式，只是不能直接通过this访问","link":"/2021/06/15/vue/define-unreactive/"},{"title":"vue-cli 全局less,sass文件的注入方法","text":"全局的mixins和variable非常有用，但是在每个文件手动引入就很费劲，需要一个一劳永逸的办法直接在编译时插入文件开头。 style-resources-loader可以解决这个问题。 12345678910111213141516// webpack-chain语法const types = ['vue-modules', 'vue', 'normal-modules', 'normal']// 业务代码注入全局变量types.forEach(type =&gt; { config.module.rule('less').oneOf(type) .use('style-resource') .loader('style-resources-loader') .options({ patterns: [ path.resolve(__dirname, `./src/style/variables.less`), path.resolve(__dirname, './src/style/mixins.less') ] })}) ‘vue-modules’, ‘vue’, ‘normal-modules’, ‘normal’这几种规则类型都是vue/cli-service定义的： 123456789101112131415161718192021function createCSSRule (lang, test, loader, options) { const baseRule = webpackConfig.module.rule(lang).test(test) // rules for &lt;style lang=&quot;module&quot;&gt; const vueModulesRule = baseRule.oneOf('vue-modules').resourceQuery(/module/) applyLoaders(vueModulesRule, true) // rules for &lt;style&gt; const vueNormalRule = baseRule.oneOf('vue').resourceQuery(/\\?vue/) applyLoaders(vueNormalRule, false) // rules for *.module.* files const extModulesRule = baseRule.oneOf('normal-modules').test(/\\.module\\.\\w+$/) applyLoaders(extModulesRule, true) // rules for normal CSS imports const normalRule = baseRule.oneOf('normal') applyLoaders(normalRule, modules) // ...} vue-cli为css,postcss,scss,sass,less,stylus这几种语言都定义了’vue-modules’, ‘vue’, ‘normal-modules’, ‘normal’这4种子规则。 我们最常用的是vue，表示.vue文件中的style标签。 参考自动化导入","link":"/2021/06/22/vue/global-style-file/"},{"title":"通过一个细节学习节点复用","text":"背景有一个图片列表，被transition-group包裹： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;template&gt;&lt;div&gt; &lt;transition-group name=&quot;movee&quot;&gt; &lt;template v-for=&quot;(img, index) in images&quot;&gt; &lt;!-- key绑定为index --&gt; &lt;!-- &lt;img class=&quot;image-item movee-item&quot; :src=&quot;img&quot; :key=&quot;index&quot; alt=&quot;&quot;&gt; --&gt; &lt;!-- key绑定为img值 --&gt; &lt;img class=&quot;image-item movee-item&quot; :src=&quot;img&quot; :key=&quot;img&quot; alt=&quot;&quot;&gt; &lt;/template&gt; &lt;/transition-group&gt; &lt;div&gt; &lt;button @click=&quot;swapImage&quot;&gt;第一张和第二张交换顺序&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt;&lt;script&gt;export default { name: 'app', data() { return { images: [ '/static/image1.png', '/static/image2.png', '/static/image3.png' ] } }, methods: { swapImage() { let first = this.images.shift() let last = this.images.pop() this.images.unshift(last) this.images.push(first) } }}&lt;/script&gt;&lt;style&gt;.image-item { height: 200px;}.movee-item { transition: all 0.3s;}&lt;/style&gt; 当for循环绑定的key为index时，没有任何动画；当key为img值时，效果如下： 为什么key绑定为img值，过渡效果就生效了呢？带着这个问题重新学习了一下vue的节点复用。 key绑定根据官方文档的说法，独特的 key，可以用于强制替换元素/组件而不是重复使用它。当你遇到如下场景时它可能会很有用： 完整地触发组件的生命周期钩子 触发过渡 那么，vue是怎么判断节点复用的呢？ vue的节点树存在vDOM中。包含了节点的所有信息。当template中绑定的data属性发生变化，就会触发新的虚拟节点生成。新旧虚拟节点会进行对比，可以复用的节点不需要重新渲染到DOM中。 同一个层级下，相同的虚拟节点才可以复用真实DOM，复用其实就是把节点对应的整个element对象粘贴到新的虚拟节点elm属性值上。新旧节点需要同时满足以下条件才能判定为相同： key 相同（不绑定key 的情况下也相同，因为都是null） tag 相同（没有tag的情况下也相同，如组件和文本节点） 如果是输入框，输入框类型也要相同 贴出源码更加直观： 123456789101112131415161718192021222324function sameVnode (a, b) { return ( a.key === b.key &amp;&amp; ( ( a.tag === b.tag &amp;&amp; a.isComment === b.isComment &amp;&amp; isDef(a.data) === isDef(b.data) &amp;&amp; sameInputType(a, b) ) || ( isTrue(a.isAsyncPlaceholder) &amp;&amp; a.asyncFactory === b.asyncFactory &amp;&amp; isUndef(b.asyncFactory.error) ) ) )}function sameInputType (a, b) { if (a.tag !== 'input') return true let i const typeA = isDef(i = a.data) &amp;&amp; isDef(i = i.attrs) &amp;&amp; i.type const typeB = isDef(i = b.data) &amp;&amp; isDef(i = i.attrs) &amp;&amp; i.type return typeA === typeB || isTextInputType(typeA) &amp;&amp; isTextInputType(typeB)} 需要注意的是，输入框等表单项的value并没有作为判断依据。即，如果input的所有属性都一样，就会被认为可以复用，input并不会被重新渲染。这也解释了为什么会存在2个输入框交换顺序后绑定值和之前的顺序一致。 关于对容一个层级的理解，看下图就清楚了： 对于整个树状的vDOM，对比过程就是深度遍历的过程。 节点复用的图示vue是如何对比同一个层级新旧子节点的呢？它其实是2种方法的结合： 两两对比交叉验证 绑定key的情况下，保存一份旧的子节点key:index键值对 两两对比始终是比较消耗性能的，这也是为什么vue针对for循环要求我们绑定key。 以同一个层级的新旧列表为例，假设数组的顺序变更为：**[A, B, C, D, E] =&gt; [F, B, A, E, C, G]**，用图展示绑定key为value的过程。 👆4个箭头分别为oldStartIndex，oldEndIndex，newStartIndex, newEndIndex。旧A-新F，旧A-新G，旧E-新F，旧E-新G这4对对应的vNode进行比较。 👆由于绑定的key值不同，认定为不同的节点。接下来将通过key:index映射来尝试找到newStartNode。 👆newStartNode通过key也没找到，因此新建一个DOM元素，插入到oldStartNode指向的DOM节点之前 👆newStartVnode已经完成DOM创建和插入，接下来右移newStartIndex 👆新B-旧A，新B-旧E，新G-旧A，新G-旧E这4对又开始对比（这里发现有个问题，新G-旧A，新G-旧E重复对比了，这算不算一个优化点呢？vue@2.6.11）。 👆对比结果又是没匹配上。新B通过key:index映射找到了原身，旧B对应的DOM节点则移动到oldStartNode的前面。 👆新B的DOM节点已经安顿好了，新B对应的old vNode位置也对应从数组删除，为了不影响现有索引位置，只是old vNode的值设置为undefined。newStartIndex右移一位。 👆新A-旧A识别为相同的节点，由于都是startIndex，因此二者对应的DOM节点在父元素中的位置保持不变。oldStartIndex和newStartIndex右移一位 👆新E-旧E识别为相同节点。旧E（oldEndIndex）对应的DOM移动到旧C（oldStartIndex）对应的DOM节点之前👇 👇oldStartIndex和newStartIndex右移一位，oldStartIndex遇到旧B的位置为undefined，继续右移。 根据上一轮的匹配结果，oldEndIndex对应vNode置空，oldEndIndex左移，newStartIndex右移👇 👆新C-旧C识别为相同的节点，由于都是startIndex，因此二者对应的DOM节点在父元素中的位置保持不变。oldStartIndex对应的vNode置空，oldStartIndex和newStartIndex右移一位。 👆oldStartIndex和oldEndIndex相遇，newStartIndex和newEndIndex相遇。新G-旧D无法识别为相同节点。通过key:index映射也无法匹配上，说明G是新增节点。 👆针对G新建DOM节点，插入oldStartIndex对应DOM节点之前。 👆由于新G已安顿好，newStartIndex右移，但是越界，因此循环终止。 👆删除oldStartIndex和oldEndIndex之间的vNode以及DOM节点。 总结 循环条件：旧startIndex &lt;= 旧endIndex 且 新startIndex &lt;= 新endIndex 若旧startIndex 与 新startIndex 匹配，则二者均右移，不需要操作DOM顺序，继续新一轮循环 若旧startIndex 与 新endIndex 匹配，则说明处于当前对比区间最后面，将DOM节点移动到旧endIndex之后。新endIndex左移，继续新一轮循环。 若旧endIndex 与 新startIndex 匹配，则说明处于当前对比区间的最前面，将DOM节点移动到旧startIndex之前。新startIndex右移，继续新一轮循环。 若旧endIndex 与 新endIndex 匹配，则二者均左移，不需要操作DOM顺序，继续新一轮循环。 若以上都不满足，则根据当前查找区间的key:index映射寻找新startNode对应的旧index。 若找到匹配元素对应位置为idxInOld，则将idxInOld对应的DOM节点移动到旧startIndex前面。新startIndex右移，继续新一轮循环。 若找不到，则新建一个DOM节点，插入到旧startIndex前面。新startIndex右移，继续新一轮循环。 若旧startIndex &gt; 旧endIndex，则为新startIndex -&gt; 新endIndex之前所有节点新建DOM节点并按顺序插入父节点的末尾。 若新startIndex &gt; 新endIndex，则删除旧startIndex -&gt; 旧endIndex之前所有节点的DOM节点 transition-group以上分析过程只是普通的节点更新流程。如果一串节点被transition-group包裹，会发生什么呢？ 源码中，如果有transition-group包裹，可复用的DOM节点顺序是不会调整的，只会新增和删除。如以上例子 **[A, B, C, D, E] =&gt; [F, B, A, E, C, G] ** 对比结束后顺序DOM节点顺序将会是: **[F, A, B, C, E, G]**： 接下来是实施过渡的步骤： 记录当前各个DOM节点的边界位置 children更新，触发render，记录旧DOM节点的边界信息（getBoundingClientRect），重新渲染新DOM（对的，没有过渡，直接按照新的顺序渲染） 触发updated钩子，记录新DOM节点的边界信息 遍历所有children cNode，若同时存在新旧位置信息，说明是复用节点，通过transform将位置重新调整到旧位置（对的，立马设置回旧的位置，前面渲染出来的效果时间很短，用户视觉上看不到，可以通过在transition-group组件的updated钩子加断点看到） 通过读取document.body.offsetHeight触发重排 将children所有节点再设置回新位置，并添加过渡类 主线程执行完，开始重排，此时会显示过渡效果 关于transition-group这里有个小问题：为什么transition-group不立即更新DOM节点？ 因为需要一个过渡效果，不能立即切换为终点状态。过渡过程完全交给transition-group处理。 回到一开始的问题为什么key绑定为img值，过渡效果就生效了呢？ 若key绑定为img时，img相同的图片才会被视为相同节点，会被记录移动前后的位置，因此有过渡效果。 若key不绑定，或者绑定为index，那么相同index的图片被视为相同节点，每个节点的位置都没有变化，因此没有过渡效果。","link":"/2019/12/06/vue/learn-node-reuse/"},{"title":"vue 的mount 过程","text":"前段时间学习了vue的源码，理清了vue的mount流程，在此做下总结。 mount过程分为2个大阶段，生成vnode，和渲染dom 生成vnodemount方法其实调用了render函数，该函数返回的就是vnode 渲染 dom这个过程主要调用了update方法。每一个vnode的渲染都会调用一次update方法。 针对组件，render返回的对应vnode只是一个占位vnode。在update的时候占位vnode会根据组件配置生成所有内容的dom。 渲染过程其实是一个深度遍历的过程。即，最先生成子dom，逐个层级向上插入，直到插入根结点的dom中。","link":"/2020/04/02/vue/mount-flow/"},{"title":"vue-router 总结","text":"路由钩子（导航守卫）全局钩子beforeEach123router.beforeEach((to, from, next) =&gt; { // ...}) 异步回调，按照钩子挂载的顺序执行。有点类似于tapable的waterfall任务队列。所有的回调必须执行next才能进行下一步。 next可以做以下事情： 中断路由跳转 跳转到一个不同的地址 中断跳转并抛出错误 beforeResolve和 router.beforeEach 类似，在 beforeEach 和 组件内beforeRouteEnter 之后，afterEach之前调用。 afterEach123router.afterEach((to, from) =&gt; { // ...}) 路由切换后的回调。无法修改路由。 路由内钩子beforeEnter和beforeEach一样。区别是，这个钩子是挂在特定路由下的，表示只有跳转到当前路由前才执行的钩子。 1234567891011const router = new VueRouter({ routes: [ { path: '/foo', component: Foo, beforeEnter: (to, from, next) =&gt; { // ... } } ]}) 组件内钩子beforeRouteEnter1234567beforeRouteEnter(to, from, next) { // 在渲染该组件的对应路由被 confirm 前调用 // 不！能！直接获取组件实例 `this` // 但是可以在next回调获取`this` // 因为当守卫执行前，组件实例还没被创建 // next一定要调用} beforeRouteUpdate12345678beforeRouteUpdate(to, from, next) { // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候， // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 可以访问组件实例 `this` // next一定要调用 // next无需传参} beforeRouteLeave1234567beforeRouteLeave(to, from, next) { // 导航离开该组件的对应路由时调用 // 可以访问组件实例 `this` // next一定要调用 // next无需传参 // next(false)可以阻止跳转} 完整的导航流程 导航被触发。 在失活的组件里调用 beforeRouteLeave 守卫。 调用全局的 beforeEach 守卫。 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。 在路由配置里调用 beforeEnter。 解析异步路由组件。 在被激活的组件里调用 beforeRouteEnter。 调用全局的 beforeResolve 守卫 (2.5+)。 导航被确认。confirmed 调用全局的 afterEach 钩子。 触发 DOM 更新。 调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。","link":"/2018/08/20/vue/vue-router/"},{"title":"vue runtime 和 esm","text":"一. esm是vue 的“运行时”和“编译器”的集合运行时运行时是用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切。 编译器用来将模板字符串编译成为 JavaScript 渲染函数的代码。 在客户端编译模板包含以下情况： el属性指定模版挂载的DOM，和该DOM包含的html，也就是说，既没有指定template，又没有render函数 用template属性指定模板渲染的字符串 如何选择vue的package.json文件中的module属性指定了模块的入口文件为vue.runtime.esm.js，为什么呢，因为这个只包含了运行时，不包含编译器。相比全部包含的vue.esm.js文件而言，vue.runtime.esm.js体积小了将近三分之一，初始化运行速度相对来说会高一些。 我发现，在开发单页应用的时候，绝大多数情况下可以避免出现使用编译器的情况，所以，我只说下我遇到的情况。 通常，我们的单页应用的入口html，入口文件和顶级组件分别是index.html, main.js和App.js。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;/div&gt; &lt;!-- built files will be auto injected --&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- main.js --&gt;import Vue from 'vue'import App from './App'Vue.config.productionTip = falsenew Vue({ el: '#app', template: '&lt;App/&gt;', components: {App}})&lt;!-- App.vue --&gt;&lt;template&gt; &lt;div&gt; HelloWorld &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'App'}&lt;/script&gt; 就像上面这种情况，初始化根实例的时候，用template指定了挂载元素，这就意味着，一定要用编译器。如果你的webpack.config.js里面没有设置vue的alias，并且，在main.js文件中，直接使用import Vue from ‘vue’，你会发现，浏览器会报错: 1[Vue warn]: You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build. 但是，如果你把 1import Vue from 'vue' 改成 1import Vue from 'vue/dist/vue.esm.js' 就会运行正常。不知道有多少项目都只是因为这个根实例导致不得不引入vue.esm.js。 那么，针对这个情况怎么解决呢？想必很多人都知道答案了。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;!-- built files will be auto injected --&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- main.js --&gt;import Vue from 'vue'import App from './App'Vue.config.productionTip = falsenew Vue({ el: '#app', render(h) { return h(App) }})&lt;!-- App.vue --&gt;&lt;template&gt; &lt;div&gt; HelloWorld &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'App'}&lt;/script&gt; 其实只改了一行代码，就是把main.js中的template替换成render函数。之前发现有的项目用render有的直接template，现在才知道是这么回事。 二. esm和common什么关系，为什么除了runtime.esm和esm之外，还有vue.common.js和vue.js呢？1. esm全称是ESModule，意思是遵循es6的import export模块化规则。2. common的意思是遵循common.js的exports模块化规则。3. 如何选择?我们知道common.js的模块化是输出一个exports对象，没法做到按需引入，一旦引入，就是用 require引入整个exports对象。但是ES6的import 可以选择引入哪些属性。 前者是运行时引入，后者是编译时引入（NodeJS打包）。由于编译时即可知道哪些是没有用到的，这样就可以达到tree shaking的目的（通过webpack配合达到）。 esm.js文件里面是符合ES6模块规则的es5的语法，是经过babel编译过的。为什么要是es5的语法呢？一般情况下业务代码在使用babel-loader的时候会exclude掉node_module目录，这是因为，node_module目录里面有大量的源代码，处理起来很浪费时间，所以干脆模块开发者帮你编译好，别人直接用你编译好的，而且能tree shaking的代码版本即可。","link":"/2020/08/01/vue/vue-runtime-compile/"},{"title":"常见的vue 报错信息","text":"模板渲染初始化问题1Proxy.render Cannot read property '0' of undefined 上面这个报错是指在构建DOM的时候，有个变量是undefined，但是这个变量被当成Array类型并访问了下标值。 这种情况通常出现在数据初始化的时候，某些属性不存在，但是访问了这个不存在的属性的子属性 计算属性绑定v-model1Computed property &quot;&quot; was assigned to but it has no setter. 通常这个报错的原因是，用一个计算属性绑定到v-model上面。 1234567891011121314// template部分&lt;el-rate v-model=&quot;rate&quot; disabled&gt;&lt;/el-rate&gt;// js部分computed: { rate() { if (this.detail) { return parseFloat(this.detail.starRating) || 0 } else { return 0 } } } 解决办法 尽量避免计算属性用在v-model上，因为计算属性一般是通过现有的值计算出来的。如果可以通过其它方式修改计算属性的话，数据状态会比较混乱。 计算属性默认是只有getter的，就是说只能取值，不能设值。computed支持手动添加set函数。具体参考vue 计算属性","link":"/2020/07/09/vue/vue-error/"},{"title":"项目静态资源CDN服务无响应情况的回源","text":"背景某日，华为云上部署的cdn服务故障导致部分区域静态资源（js和css）响应超时。这种情况是我们没有预料到的，幸亏用户不多，否则需要紧急发版将静态资源指向源服务器。 我们的项目采用uni-app框架开发，内部基于vue-cli。生产模式会使用publicPath配置将静态资源指向cdn服务器，即，代码经过webpack编译后资源引用地址就已经固定了。 任务拆解为了应对以上情况，我们需要实现一种机制，能够识别cdn异常，并切换资源为源服务器。 我们的任务分为以下： publicPath运行时全局变更 cdn资源请求异常识别方法 资源开关切换机制 方案分析与实施publicPath运行时全局变更经过分析打包后的模块代码： 123456/******/ function jsonpScriptSrc(chunkId) {/******/ return __webpack_require__.p + &quot;static/js/&quot; + ({&quot;project-qlymain-pages-404&quot;:&quot;project-qlymain-pages-404&quot;}[chunkId]||chunkId) + &quot;.&quot; + {&quot;chunk-0826ee9b&quot;:&quot;964d9183&quot;,&quot;chunk-69a5a22c&quot;:&quot;9e1c8209&quot;,&quot;project-qlymain-pages-404&quot;:&quot;330de720&quot;}[chunkId] + &quot;.js&quot;/******/ }/******/ ....此处省略一些中间代码/******/ // __webpack_public_path__/******/ __webpack_require__.p = &quot;/&quot;; 以及webpack源码： 123456789this.hooks.requireExtensions.tap(&quot;MainTemplate&quot;, (source, chunk, hash) =&gt; { const buf = []; const chunkMaps = chunk.getChunkMaps(); // ... // ... buf.push(&quot;// __webpack_public_path__&quot;); buf.push(`${this.requireFn}.p = ${JSON.stringify(publicPath)};`); return Template.asString(buf);}); 可以发现，publicPath被写入模块属性__webpack_require__.p上，我只需要修改这个属性值就可以了。 一开始我写了个插件，通过拦截compiler钩子修改这个模块属性： 12345678910111213141516function pushBuff(valName, defaultVal, source) { var buf = []; buf.push(source); buf.push(''); buf.push('// Dynamic assets path override (/build/plugins/runtime-publicpath-plugin)'); buf.push(`__webpack_require__.p = ${valName} || '${defaultVal}'`); return buf.join('\\n');}// ...if (compiler.hooks &amp;&amp; compiler.hooks.thisCompilation) { compiler.hooks.thisCompilation.tap('RuntimePublicpathPlugin', function (compilation) { compilation.mainTemplate.hooks.requireExtensions.tap('RuntimePublicpathPlugin', function (source, chunk, hash) { return pushBuff(globalVariable, defaultPublicPath, source) }) });} 但是，这个插件的目的是覆盖__webpack_require__.p的值为runtime的运行时全局变量（window[globalVariable]），但是我们的开关状态可能要存储到localstorage中（因为要实现状态缓存），而且存进去的字段名由业务代码决定，这样就导致插件和业务过渡耦合。 后来发现业务代码中可以使用webpack提供的变量webpack_public_path，webpack会在编译时将这些变量替换成__webpack_require__.p。 至此，我们找到了publicPath运行时的覆盖方法： 1__webpack_public_path__ = localstorage.getItem('__webpack_public_path__') 异步资源加载打包后按需加载的代码： 1234567891011121314// script path functionfunction jsonpScriptSrc(chunkId) { return __webpack_require__.p + &quot;&quot; + ({ &quot;project-qlymall-views-order-logisticsDetail&quot;:&quot;project-qlymall-views-order-logisticsDetail&quot;, &quot;project-qlymall-views-order-refundDetail&quot;:&quot;project-qlymall-views-order-refundDetail&quot; // ...... }[chunkId]||chunkId)+'.js'}// ......// 创建script标签/******/ var script = document.createElement('script');/******/ // ....../******/ script.src = jsonpScriptSrc(chunkId);/******/ 为了使我们的开关机制生效，需要保证jsonpScriptSrc方法在publicPath变更后执行。实施发现只要将以下语句放在入口文件最顶部执行即可。 1__webpack_public_path__ = localstorage.getItem('__webpack_public_path__') 插入index.html的cdn标签需要重写处理完异步加载的资源，我们还要处理入口index.html的资源。vue-cli内部使用了html-webpack-plugin将所有的assets插入了index.html中，包括pulicPath： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, viewport-fit=cover&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://mycdn.mycompany.com/static/index.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script src=https://mycdn.mycompany.com/static/js/index.bd9cfc6f.js&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 如何处理这种情况呢？有2个思路。 本着解决问题不如绕开问题的原则，考虑入口文件代码直接内联 入口文件也使用异步加载的方法 针对方案1，看起来很简单粗暴，但是会产生一个问题：index.html使用的是源站资源，而非cdn。index.js一般代码比较大，如果内联是不是本身就违背了cdn的初衷呢？所以最终我们采用了方案2。 入口文件异步加载让入口文件异步加载的方法，一开始想到的方案是，写插件，覆盖vue-cli使用html-webpack-plugin的默认行为，替代为动态插入script标签的逻辑，这段代码由于不经过babel，所以语法需要谨慎。想想这样做有点大费周章了。 后来发现可以直接覆盖掉入口文件，我们称之为main2.js，该文件关键代码： 1234/* 加载主入口文件 */import('@/main.js').catch(err =&gt; { handleError(err)}) 这样就巧妙实现了入口文件异步加载。那么问题来了，main2.js又会被html-webpack-plugin插入index.html。由于main2.js的代码量较少，我选择内联，使用HtmlWebpackInlineSourcePlugin将main.js内联到index.html中。 index.css的处理在调试HtmlWebpackInlineSourcePlugin的过程中发现，index.css并不在assets列表中。我们看看index.css的生成代码： 这段代码做了2件事： 通过检查html中有没有VUE_APP_INDEX_CSS_HASH来判断生辰的index.css文件名要不要带上hash 将@dcloudio/uni-h5/dist/index.css文件中的内容取出来再加工，用copyWebpackPlugin插件将文件粘贴到dist目录中。 鉴于该文件不大，可以选择内联或者在main2.js中动态插入link标签。我选择了后者。 既然选择了动态插入link标签，就要知道，index.[hash].css的文件名，如何在运行时知晓呢？很简单，使用definePlugin将VUE_APP_INDEX_CSS_HASH注入运行时即可。 cdn加载异常识别一开始想到的是使用window.addEventListener(‘error’)，但是尝试后发现无法捕获promise中的异常，所以改用window.addEventListener(‘unhandledrejection’)。 在回调中，需要做判断区分是否是资源加载超时。通过分析webpack模块源码可以发现它有做超时异常处理： 且超时时间可以通过output.chunkLoadTimeout配置修改，默认值是120s，觉得太长的可以考虑覆盖。对于现在的用户来说，12s都算很长了，所以我选择缩短到12s。此外，超时异常格式可以通过上图的type和message匹配。 cdn开关切换针对开关切换，一开始想到的方案是通过接口变更开关状态，但是这样存在以下问题： 简单的开关可以通过人为控制apollo字段实现，但是无法感知客户端异常。开发者需要实现一个客户端告警机制触发开关变更，实现成本较高。 开关属于全局性的，一旦切换到源服务器，将会对源服务器造成较大压力。 后来选择客户端自行切换开关的方案： 识别到cdn加载超时之后，我们业务的处理逻辑是：切换开关，将开关缓存5min，缓存的原因是，我们的业务属于APP内嵌h5，每个窗口都会重新初始化，所以需要窗口之间开关状态共享。 难点清单 找到动态资源拼接的代码，找到__webpack_require__.p，如何重写它，使得运行时可修改index.css处理 内联？还是动态插入的选择 index.css文件名有hash怎么办","link":"/2021/05/27/webpack/cdn-switch/"},{"title":"webpack中的chunk和bundle","text":"chunk是webpack运行时的概念，bundle是webpack的执行结果，即生成了多少个文件。 chunk和entry一个entry对应一个chunk。chunk属于一个webpack构建过程中的概念。一个entry对应一个依赖树，这个依赖树所有依赖的集合就是一个chunk。 原始条件下，每个chunk对应生成一个bundle。 如果多个entry之间存在包含关系，则可能一个bundle打包多个chunk。 1234entry: { index: './src/index.js', add: './src/add.js'}, index引用了add.js。最终的打包结果，index.js中包含了chunk 0，即出现了重复打包。 1234567891011121314Hash: 8471c9024ea2740e855fVersion: webpack 4.46.0Time: 3338msBuilt at: 2021-06-02 11:59:15 AM Asset Size Chunks Chunk Names add.js 987 bytes 0 [emitted] addindex.js 72.5 KiB 1, 0 [emitted] indexEntrypoint index = index.jsEntrypoint add = add.js[0] ./src/add.js 49 bytes {0} {1} [built][1] ./node_modules/lodash/lodash.js 531 KiB {1} [built][2] ./src/index.js 89 bytes {1} [built][3] (webpack)/buildin/global.js 472 bytes {1} [built][4] (webpack)/buildin/module.js 497 bytes {1} [built] sourcemap和chunksoucemap选项如果不含inline，则会针对每个bundle生成生成一个map文件。 同名js文件和map文件同属于一个chunk。 runtimechunk它的作用是将包含chunks 映射关系的 list单独从 app.js里提取出来，因为每一个 chunk 的 id 基本都是基于内容 hash 出来的。 想一下这个场景，app.js-&gt;about.js。about因为某种原因（如按需加载）被打包为单独的bundle。每次about变化，就意味着about的hash变化，app.js中存在对about.js的引用路径，进而导致app.js也变化。 单独抽离 runtimeChunk 之后，每次打包都会生成一个runtimeChunk.xxx.js，其实这个文件非常的小，gzip 之后一般只有几 kb，但这个文件又经常会改变，我们每次都需要重新请求它，它的 http 耗时远大于它的执行时间了，所以建议不要将它单独拆包，而是将它内联到我们的 index.html 之中(index.html 本来每次打包都会变)。可以使用 inline-manifest-webpack-plugin或者 assets-webpack-plugin等来实现内联的效果。 runtimeChunk值为true或者’multiple’时会为每个entry生成1个文件。值为false时，所有的entry bundle共用一个chunk。 生成的runtime chunk需要插入index.html。 参考：webpack中的runtimeChunk spiltChunks该选项可以配置chunk之间的公共模块独立生成chunk，或者满足某些正则的模块独立出一个chunk。因此，该选项影响最终的bundle和chunk数目。 123456789101112131415161718192021222324252627282930313233const path = require('path')module.exports = { mode: 'production', devtool: 'none', entry: { index: './src/index.js', add: './src/add.js' }, output: { filename: '[name].[contenthash:8].js', path: path.resolve(__dirname, 'dist') }, optimization: { runtimeChunk: true, minimize: false, splitChunks: { cacheGroups: { common: { chunks: 'initial', minChunks: 2, minSize: 0, name: 'common' }, vendor: { test: /node_modules/, chunks: 'initial', name: 'vendor', enforce: true } } } }} 以上配置生成结果如下： 1234567891011121314 Asset Size Chunks Chunk Names add.559b3164.js 81 bytes 1 [emitted] [immutable] add common.a3657c09.js 326 bytes 0 [emitted] [immutable] common index.56507b59.js 739 bytes 2 [emitted] [immutable] index runtime~add.a5423113.js 6.11 KiB 3 [emitted] [immutable] runtime~addruntime~index.626b59fe.js 6.11 KiB 4 [emitted] [immutable] runtime~index vendor.4939a6bb.js 533 KiB 5 [emitted] [immutable] [big] vendorEntrypoint index [big] = runtime~index.626b59fe.js common.a3657c09.js vendor.4939a6bb.js index.56507b59.jsEntrypoint add = runtime~add.a5423113.js common.a3657c09.js add.559b3164.js[0] ./node_modules/lodash/lodash.js 531 KiB {5} [built][1] ./src/add.js 49 bytes {0} [built][2] ./src/index.js 147 bytes {2} [built][3] (webpack)/buildin/global.js 472 bytes {5} [built][4] (webpack)/buildin/module.js 497 bytes {5} [built] add.559b3164.js和index.56507b59.js是由于entry生成的。 common.a3657c09.js和vendor.4939a6bb.js是由于splitChunks生成的。 runtimeadd.a5423113.js和runtimeindex.626b59fe.js是由于runtimeChunk: true生成的。","link":"/2021/06/02/webpack/chunk-bundle/"},{"title":"从tapable学习Function构造函数的用法","text":"tapable是webpack实现插件机制的核心。插件通过tapable注册到webpack的执行过程中的各个事件节点。当执行过程到达对应节点时，tapable上注册的插件就会以该事件节点要求的方式执行。 tapable执行插件队列的实现，是通过在运行时根据调用方法，使用Function构造函数动态构造新的函数并执行。 如： 123456789101112131415// 初始化钩子列表const hook = new AsyncSeriesHook()// 挂载钩子hook.tapAsync('tap1', (callback) =&gt; { setTimeout(() =&gt; { callback('tap1') }, 0)})hook.tapPromise('tap2', () =&gt; { return Promise.resolve('tap2')})// 执行钩子hook.callAsync((res) =&gt; { console.log(res)}) callAsync方法执行过程中，使用new Function拼接新函数，生成结果如下： 123456789101112131415161718192021222324252627function(_callback) { &quot;use strict&quot;; var _context; var _x = this._x; function _next0() { var _fn1 = _x[1]; var _hasResult1 = false; var _promise1 = _fn1(); if (!_promise1 || !_promise1.then) throw new Error('Tap function (tapPromise) did not return promise (returned ' + _promise1 + ')'); _promise1.then((function (_result1) { _hasResult1 = true; _callback(); }), function (_err1) { if (_hasResult1) throw _err1; _callback(_err1); }); } var _fn0 = _x[0]; _fn0((function (_err0) { if (_err0) { _callback(_err0); } else { _next0(); } }));} 使用方法1new Function ([arg1[, arg2[, ...argN]],] functionBody) functionBody 一个字符串，表示函数体的内容。 以下代码： 12345const adder = new Function(&quot;a&quot;, &quot;b&quot;, ` if (isNaN(a) || isNaN(b)) return return a + b`); 生成的函数就如下： 12345678(function anonymous(a,b) { if (isNaN(a) || isNaN(b)) return return a + b}) 作用域MDN表示，Function动态生成的函数，作用域为全局作用域，而不是创建函数时所在的作用域。 tapabel就想到一个办法，将动态的生成的函数，动态绑定到类实例方法上，在动态函数中直接访问’this’上的属性，即实例属性。 安全问题new Function由于是动态生成代码，因此会存在安全问题。在配置了CSP安全策略的浏览器页面中执行会有以下报错： 12345Uncaught EvalError: Refused to evaluate a string as JavaScript because 'unsafe-eval' is not an allowed source of script in the following Content Security Policy directive: &quot;script-src 'report-sample' 'self' *.speedcurve.com 'sha256-q7cJjDqNO2e1L5UltvJ1LhvnYN7yJXgGO7b6h9xkL1o=' www.google-analytics.com/analytics.js 'sha256-JEt9Nmc3BP88wxuTZm9aKNu87vEgGmKW1zzy/vb1KPs=' polyfill.io/v3/polyfill.min.js assets.codepen.io production-assets.codepen.io&quot;. at new Function (&lt;anonymous&gt;) at &lt;anonymous&gt;:1:15(anonymous) @ VM54:1 因此，Function构造函数一般不适用于在浏览器端使用。","link":"/2021/08/02/webpack/function-constructor/"},{"title":"webpack学习笔记","text":"有这样一个模块： 12345// src/base/b.jsfunction foo() { console.log('function foo')}module.exports = foo development ‘eval-source-map’b模块的编译结果为： 12345678910/***/ &quot;./src/base/b.js&quot;:/*!***********************!*\\ !*** ./src/base/b.js ***! \\***********************//*! no static exports found *//***/ (function(module, exports) {eval(&quot;function foo() {\\n console.log('function foo');\\n}\\n\\nmodule.exports = foo;//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYmFzZS9iLmpzP2Q5YjYiXSwibmFtZXMiOlsiZm9vIiwiY29uc29sZSIsImxvZyIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBLFNBQVNBLEdBQVQsR0FBZTtBQUNiQyxTQUFPLENBQUNDLEdBQVIsQ0FBWSxjQUFaO0FBQ0Q7O0FBQ0RDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkosR0FBakIiLCJmaWxlIjoiLi9zcmMvYmFzZS9iLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gZm9vKCkge1xuICBjb25zb2xlLmxvZygnZnVuY3Rpb24gZm9vJylcbn1cbm1vZHVsZS5leHBvcnRzID0gZm9vIl0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///./src/base/b.js\\n&quot;);/***/ }) eval方法的注释部分便是sourcemap。包含 sourceURL。 sourceMappingURL该部分是base64编码。解码后如下： 1234567891011121314151617181920212223242526{ // sourcemap版本号是3 &quot;version&quot;: 3, // 源码地址，可能由多个模块合并，因此为数组格式。后面的hash用来刷新浏览器缓存。 &quot;sources&quot;: [ &quot;webpack:///./src/base/b.js?d9b6&quot; ], // 转换前的所有变量名、属性名、方法名 &quot;names&quot;: [ &quot;foo&quot;, &quot;console&quot;, &quot;log&quot;, &quot;module&quot;, &quot;exports&quot; ], // 记录位置信息的字符串 &quot;mappings&quot;: &quot;AAAA,SAASA,GAAT,GAAe;AACbC,SAAO,CAACC,GAAR,CAAY,cAAZ;AACD;;AACDC,MAAM,CAACC,OAAP,GAAiBJ,GAAjB&quot;, // 转换后的文件名，这里不清楚为什么后缀名重复 &quot;file&quot;: &quot;./src/base/b.js.js&quot;, // 转换后的代码，目测分行存储在数组中 &quot;sourcesContent&quot;: [ &quot;function foo() {\\n console.log('function foo')\\n}\\nmodule.exports = foo&quot; ], // 转换前的文件所在的目录。如果与转换前的文件在同一目录，该项为空 &quot;sourceRoot&quot;: &quot;&quot;} mappings 每个分号对应转换后源码的一行； 每个逗号对应转换后源码的一个位置； 每个位置通常是5位； 5位的位置说明： 第一位，表示这个位置在【转换后代码】的第几列。 第二位，表示这个位置属于【sources属性】中的哪一个文件。 第三位，表示这个位置属于【转换前代码】的第几行。 第四位，表示这个位置属于【转换前代码】的第几列。 第五位，表示这个位置属于【names属性】的哪一个变量。该位置非必须。如果不是属性或变量则为空。 不需要保存转换后的行号，因为mappings中的分号就是行分割符。 每一行的位置数据，第一、三、四位都属于相对位置，相对mappings中前一个元素的位置，第三、四位的相对位置要看转换前的代码。 参考资料：source-map 的原理 1234567// 转换前function foo() { console.log('function foo')}module.exports = foo// 转换后function foo() {\\n console.log('function foo');\\n}\\n\\nmodule.exports = foo; 使用base64-vlq库或者站长工具将mappings解码： 1234567891011121314// 源码&quot;mappings&quot;: &quot;AAAA,SAASA,GAAT,GAAe;AACbC,SAAO,CAACC,GAAR,CAAY,cAAZ;AACD;;AACDC,MAAM,CAACC,OAAP,GAAiBJ,GAAjB&quot;// 解码后：0) [0,0,0,0], [9,0,0,9,0], [3,0,0,-9], [3,0,0,15]1) [0,0,1,-13,1], [9,0,0,7], [1,0,0,1,1], [3,0,0,-8], [1,0,0,12], [14,0,0,-12]2) [0,0,1,-1]4) [0,0,1,-1,1], [6,0,0,6], [1,0,0,1,1], [7,0,0,-7], [3,0,0,17,-4], [3,0,0,-17]// 绝对位置(([from_position](source_index)=&gt;[to_position]))([0,0](#0)=&gt;[0,0]) | ([0,9](#0)=&gt;[0,9]) | ([0,0](#0)=&gt;[0,12]) | ([0,15](#0)=&gt;[0,15])([1,-13](#0)=&gt;[1,0]) | ([1,-6](#0)=&gt;[1,9]) | ([1,-5](#0)=&gt;[1,10]) | ([1,-13](#0)=&gt;[1,13]) | ([1,-1](#0)=&gt;[1,14]) | ([1,-13](#0)=&gt;[1,28])([2,-1](#0)=&gt;[2,0])([3,-1](#0)=&gt;[4,0]) | ([3,5](#0)=&gt;[4,6]) | ([3,6](#0)=&gt;[4,7]) | ([3,-1](#0)=&gt;[4,14]) | ([3,16](#0)=&gt;[4,17]) | ([3,-1](#0)=&gt;[4,20]) 解码是确实解码了，位置看起来有点对不上，估计是算法没理解对，先不管了。 参考资料： An Introduction to Source Maps 浏览器加载sourcemap以chrome为例，preferences面板可以开启sourcemap支持： 浏览器自动识别代码中的sourceURL字段并加载对应的代码。 有了sourcemap，浏览器自动会解析源代码的位置。 这里有一点细节。 sourceMappingURL中的sources字段，路径格式为webpack:///。sourceURL的路径格式为webpack-internal:///。 sourceURL是用来给eval方法内的代码字符串命名的。webpack-dev-server编译后的代码是通过eval执行的。浏览器直接以该文件名建立新文件，调试时可以直接打开这个新文件，而不用在定位到eval方法中。 sourceMappingURL中的sources内的文件为转化前的代码路径，用来调试时报错定位。","link":"/2021/06/20/webpack/sourcemap/"},{"title":"tapable学习笔记","text":"tapable内部关系结构图tapable官方文档写的过于简洁，如果想要搞清楚tap类型、钩子类型、call类型之间的关系，还是得看源码才行。以下是我整理出来的关系结构图： 简单示例以AsyncSeriesHook的callAsync为例，分别插入一个promise和async类型的插件： 123456789101112131415// 初始化钩子列表const hook = new AsyncSeriesHook()// 挂载钩子hook.tapAsync('tap1', (callback) =&gt; { setTimeout(() =&gt; { callback('tap1') }, 0)})hook.tapPromise('tap2', () =&gt; { return Promise.resolve('tap2')})// 执行钩子hook.callAsync((res) =&gt; { console.log(res)}) 插件挂载tapAsync和tapPromise方法会将插件插入tap数组中。 插件执行AsyncSeriesHook为异步串行执行插件队列：执行完每个插件后都会接着执行下一个插件。 插件执行的代码是经过包裹封装的。以上代码封装后的结构如下： 123456789101112131415161718192021222324252627function(_callback) { &quot;use strict&quot;; var _context; var _x = this._x; function _next0() { var _fn1 = _x[1]; var _hasResult1 = false; var _promise1 = _fn1(); if (!_promise1 || !_promise1.then) throw new Error('Tap function (tapPromise) did not return promise (returned ' + _promise1 + ')'); _promise1.then((function (_result1) { _hasResult1 = true; _callback(); }), function (_err1) { if (_hasResult1) throw _err1; _callback(_err1); }); } var _fn0 = _x[0]; _fn0((function (_err0) { if (_err0) { _callback(_err0); } else { _next0(); } }));} 以上是callAsync最终执行的函数。 _callback就是callAsync传入的回调 this._x指的是tap数组 _next0内部封装了插件tap2的执行语句 当tap1插件，即_fn0方法的callback调用时无传参，则表示插件正常结束，可以执行_next0。否则不继续执行剩余的插件，直接结束队列并调用_callback 总结 tap方法类型决定了插件类型 钩子类型其实是插件的执行顺序和插件传参/终止条件的组合，和插件类型无关 钩子执行方式中，同步钩子只能用同步方法调用。异步钩子只能用异步方法调用。 插件类型取决于插件本身的需求，无需迁就钩子类型。只不过，异步插件就不要挂载到同步钩子类型上。 promise和callAsync方法的不同体现在，插件队列结束时通过何种方式执行钩子回调。call方法无需回调。","link":"/2021/07/24/webpack/tapable/"},{"title":"webpack 工作流程","text":"之前一直对webpack的工作流程搞不清楚，compiler和compilation傻傻分不清。带着以下目的，粗略看了下源码，整理了它的工作流程。","link":"/2021/07/12/webpack/work-flow/"},{"title":"微信开发者工具的小tips","text":"默认选项开关project.config.json可以配置开发者工具的一些选项开关，不用每次不厌其烦的等模拟器渲染完再去一个个的关闭了。 project.config.json 其中，packOptions可以配置代码上传时的忽略目录。 open-data组件用户个人信息展示可以使用组件，无需再去调用各种api了。 指定对应的type即可显示对应的信息。支持的类型有： 12345678groupNameuserNickNameuserAvatarUrluserGenderuserCityuserProvinceuserCountryuserLanguage 还可以在open-data上绑定class,style设置样式。","link":"/2021/06/12/weixin-mp/devtool-tips/"},{"title":"小程序图片长按识别码兼容性整理","text":"码类型 | 公众号文章 | 小程序image标签 + show long press menu | 小程序wx.previewImage | 小程序webview内 | 小程序客服消息—|—视频号二维码 | Yes 8.0.2- NO（1） 8.0.2- NO Yes个人赞赏码 | Yes | 8.0.2- NO | | 8.0.2- NO | Yes微信名片/群二维码 | Yes | 8.0.2- NO | ios 8.0.6+android 8.0.3+（3） | ios 8.0.6+android 8.0.3+（3） | Yes个人收款二维码 | Yes | 8.0.2- NO | | 8.0.2- NO | Yes公众号（订阅号） | 二维码 | Yes | 8.0.2- NO | 公众号文章：Yes | 其它：NO | Yes小程序码 | Yes | Yes | Yes | Yes | Yes小程序二维码 | Yes | 8.0.2- NO | 8.0.2- NO | 8.0.6- NO | Yes小商店码 | Yes | Yes | Yes | Yes企业微信二维码 | Yes | android | 8.0.3- NO（亲测） | ios 8.0.7 | Yes（亲测） | ios 8.0.6+（亲测） | android 8.0.3+（亲测） | Yes普通网址二维码 | Yes | 8.0.2- NO | | 8.0.2- NO | Yes 小程序内图片长按功能（非previewImage）：版本 | 小程序内image组件show-menu-by-longpress属性 | 小程序webview内img标签长按出现菜单7.0.x+ | 安卓/ios | 支持小程序码识别8.0.3 | 安卓：支持识别微信个人码、企业微信个人码、普通群码与互通群码（企业微信活码不支持） | （3）8.0.6 | 苹果：支持识别微信个人码、企业微信个人码、普通群码与互通群码（企业微信活码不支持），但点击弹窗菜单没有反应（bug）8.0.7 | 苹果：点击长按弹窗菜单没有反应的bug修复 参考链接：（1） https://developers.weixin.qq.com/community/develop/doc/0008ea7edb8f4845c39be413456c00?highLine=%25E8%25B5%259E%25E8%25B5%258F%25E7%25A0%2581%25E8%25AF%2586%25E5%2588%25AB（2）https://developers.weixin.qq.com/community/develop/article/doc/00008e4f3bc538998bfb344ec56413（3）https://developers.weixin.qq.com/community/develop/article/doc/000ae09dcfc8887e4b4c287e75b813（4）https://mp.weixin.qq.com/s/QyJ4XKgaYH-517PEElhwrg","link":"/2021/06/30/weixin-mp/scan-code/"},{"title":"微信小程序中scroll-view问题总结","text":"ios设备中fix定位元素在scroll-view中会被遮挡scroll-view内部如果有fix定位元素，由于ios设备有弹动功能，一旦scroll-view被拉到不包含fix定位的元素之外，fix定位元素会被遮挡 scroll-view中无法置于顶层scroll-view内部的fix定位元素，无论z-index设置为多少，都无法置于scroll-view外部fix定位元素的上层。 解决办法这个问题在h5和小程序中都存在。原因是：scroll-view元素在ios下的样式包含以下属性： 1-webkit-overflow-scrolling: touch 该属性的作用是让touch滚定行为更加流畅：https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-overflow-scrolling 但是，该属性值为touch时会影响容器内的fixed元素层级，改为auto就不会影响了，但是touch属性值目前是有必要存在的。https://developers.weixin.qq.com/community/develop/doc/0000667484c96844b83ac9c7651809?_at=1617789574414https://developers.weixin.qq.com/community/develop/doc/0004aeafeccb789ac219e474756000解决方式是将fixed定位元素移到scroll-view外面。 safari 13.0以上的版本解决办法safari 13.0以上的版本就不需要该属性了(https://developer.apple.com/documentation/safari-release-notes/safari-13-release-notes) 了解了原因之后，我们分析下ios系统版本占比： (数据来源：腾讯大数据-&gt;腾讯移动分析 MTA) 可见97%的用户版本号&gt;13，可以放心的移除了。拿个ios 13真机试下，果然没问题。 内部垂直方向margin在安卓设备出现双滚动条123456789101112131415161718&lt;template&gt;&lt;scroll-view class=&quot;product-wrap&quot; scroll-y enable-back-to-top &gt; &lt;view class=&quot;product-item&quot;&gt;&lt;/view&gt; &lt;/scroll-view&gt; &lt;/template&gt; &lt;style&gt; .product-wrap { height: 100%; } .product-item { margin-top: 20rpx; } &lt;/style&gt; 以上代码会导致安卓设备页面滚动出现双滚动条。需要为内部元素加一层包裹，称为BFC，防止margin塌陷: 123456789101112131415161718192021&lt;template&gt;&lt;scroll-view class=&quot;product-wrap&quot; scroll-y enable-back-to-top &gt; &lt;view class=&quot;product-container&quot;&gt;&lt;view class=&quot;product-item&quot;&gt;&lt;/view&gt;&lt;/view&gt; &lt;/scroll-view&gt; &lt;/template&gt; &lt;style&gt; .product-wrap { height: 100%; } .product-container { overflow: hidden; } .product-item { margin-top: 20rpx; } &lt;/style&gt;","link":"/2021/06/17/weixin-mp/scroll-view/"},{"title":"微信小程序分享能力整理","text":"小程序分享到朋友圈的方式整理 分享方式 分享文案格式 朋友圈点击交互方式 支持度 额度限制 APP内分享到微信朋友圈 和公众号H5一致 1. 点击朋友圈图文链接先打开一个H5页面2. 用户手动点击页面内的按钮打开小程序 无限制，都支持 1. 短期链接+长期链接每日上限50万2. 长期链接总数不超过10万3. 时长超过30天或者永久类型都称为长期链接 小程序直接分享到微信朋友圈（从小程序内自动打开朋友圈） 和公众号H5一致 1. 点击朋友圈图文链接先打开对应的详情页面（H5页面，代码需要做适配）2. 点击页面底部的“前往小程序”按钮打开小程序 目前仅安卓端支持 无额度限制 小程序生成海报分享到微信朋友圈（和app内生成海报交互一致，用户手动保存海报，手动打开朋友圈分享） 海报 长按海报图片识别 无限制，都支持 无额度限制 参考资料： https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/share-timeline.html#%E8%AE%BE%E7%BD%AE%E5%88%86%E4%BA%AB%E7%8A%B6%E6%80%81 https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/url-scheme.html https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/short-link/shortlink.generate.html#HTTPS-%E8%B0%83%E7%94%A8","link":"/2021/07/19/weixin-mp/share/"},{"title":"小程序web-view内嵌h5的能力整理","text":"个性化布局能力web-view自动铺满整屏，无法自定义web-view窗口大小。且小程序页面没有任何组件能够高于webview的层级。 通信能力小程序向webview通信：url传参 webview通信向小程序通信：jssdk.postmessage。非实时触发，触发条件：小程序后退、组件销毁（移除webview组件）、分享 关于小程序后退、组件销毁、分享的时机，需要实际测试方知晓具体的限制。 实时通信：暂时未提供 支付能力不支持H5内支付功能 参考资料 小程序webview内嵌H5支付页面，H5能正常支付吗 webview内的jssdk支持的api列表说明","link":"/2021/06/07/weixin-mp/webview/"}],"tags":[{"name":"微前端","slug":"微前端","link":"/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/"},{"name":"qiankun","slug":"qiankun","link":"/tags/qiankun/"},{"name":"百度地图sdk","slug":"百度地图sdk","link":"/tags/%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BEsdk/"},{"name":"base64","slug":"base64","link":"/tags/base64/"},{"name":"CSP","slug":"CSP","link":"/tags/CSP/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"布局","slug":"布局","link":"/tags/%E5%B8%83%E5%B1%80/"},{"name":"https","slug":"https","link":"/tags/https/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"H5","slug":"H5","link":"/tags/H5/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"原型链","slug":"原型链","link":"/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"name":"代理","slug":"代理","link":"/tags/%E4%BB%A3%E7%90%86/"},{"name":"正则","slug":"正则","link":"/tags/%E6%AD%A3%E5%88%99/"},{"name":"权限","slug":"权限","link":"/tags/%E6%9D%83%E9%99%90/"},{"name":"运营后台","slug":"运营后台","link":"/tags/%E8%BF%90%E8%90%A5%E5%90%8E%E5%8F%B0/"},{"name":"防抖节流","slug":"防抖节流","link":"/tags/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"nuxt","slug":"nuxt","link":"/tags/nuxt/"},{"name":"charles","slug":"charles","link":"/tags/charles/"},{"name":"debug","slug":"debug","link":"/tags/debug/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"fiddler","slug":"fiddler","link":"/tags/fiddler/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"Jenkins","slug":"Jenkins","link":"/tags/Jenkins/"},{"name":"vscode","slug":"vscode","link":"/tags/vscode/"},{"name":"学习","slug":"学习","link":"/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"uni-app","slug":"uni-app","link":"/tags/uni-app/"},{"name":"打包路径","slug":"打包路径","link":"/tags/%E6%89%93%E5%8C%85%E8%B7%AF%E5%BE%84/"},{"name":"组件","slug":"组件","link":"/tags/%E7%BB%84%E4%BB%B6/"},{"name":"条件编译","slug":"条件编译","link":"/tags/%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91/"},{"name":"环境变量","slug":"环境变量","link":"/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"},{"name":"错误捕获","slug":"错误捕获","link":"/tags/%E9%94%99%E8%AF%AF%E6%8D%95%E8%8E%B7/"},{"name":"rpx","slug":"rpx","link":"/tags/rpx/"},{"name":"treeShaking","slug":"treeShaking","link":"/tags/treeShaking/"},{"name":"长按复制","slug":"长按复制","link":"/tags/%E9%95%BF%E6%8C%89%E5%A4%8D%E5%88%B6/"},{"name":"分包优化","slug":"分包优化","link":"/tags/%E5%88%86%E5%8C%85%E4%BC%98%E5%8C%96/"},{"name":"thread-loader","slug":"thread-loader","link":"/tags/thread-loader/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"全局样式","slug":"全局样式","link":"/tags/%E5%85%A8%E5%B1%80%E6%A0%B7%E5%BC%8F/"},{"name":"vue-cli","slug":"vue-cli","link":"/tags/vue-cli/"},{"name":"node-reuse","slug":"node-reuse","link":"/tags/node-reuse/"},{"name":"vue-router","slug":"vue-router","link":"/tags/vue-router/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"cdn","slug":"cdn","link":"/tags/cdn/"},{"name":"chunk","slug":"chunk","link":"/tags/chunk/"},{"name":"tapable","slug":"tapable","link":"/tags/tapable/"},{"name":"sourcemap","slug":"sourcemap","link":"/tags/sourcemap/"},{"name":"微信开发者工具","slug":"微信开发者工具","link":"/tags/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/"},{"name":"mp-weixin","slug":"mp-weixin","link":"/tags/mp-weixin/"},{"name":"微信","slug":"微信","link":"/tags/%E5%BE%AE%E4%BF%A1/"},{"name":"小程序","slug":"小程序","link":"/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"categories":[{"name":"工程化","slug":"工程化","link":"/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"其它","slug":"其它","link":"/categories/%E5%85%B6%E5%AE%83/"},{"name":"web安全","slug":"web安全","link":"/categories/web%E5%AE%89%E5%85%A8/"},{"name":"js","slug":"js","link":"/categories/js/"},{"name":"css","slug":"css","link":"/categories/css/"},{"name":"网络","slug":"网络","link":"/categories/%E7%BD%91%E7%BB%9C/"},{"name":"工具","slug":"工具","link":"/categories/%E5%B7%A5%E5%85%B7/"},{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"H5","slug":"H5","link":"/categories/H5/"},{"name":"html","slug":"html","link":"/categories/html/"},{"name":"nuxt","slug":"nuxt","link":"/categories/nuxt/"},{"name":"思考","slug":"思考","link":"/categories/%E6%80%9D%E8%80%83/"},{"name":"uni-app","slug":"uni-app","link":"/categories/uni-app/"},{"name":"vue","slug":"vue","link":"/categories/vue/"},{"name":"小程序","slug":"小程序","link":"/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]}